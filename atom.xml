<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Harvey`s note</title>
  
  <subtitle>专注当前的任务，控制支出</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://harveyyeung.github.io/"/>
  <updated>2018-01-17T04:15:45.739Z</updated>
  <id>https://harveyyeung.github.io/</id>
  
  <author>
    <name>Harvey</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PracPythonOpenCV6</title>
    <link href="https://harveyyeung.github.io/2018/01/17/PracPythonOpenCV6/"/>
    <id>https://harveyyeung.github.io/2018/01/17/PracPythonOpenCV6/</id>
    <published>2018-01-17T04:10:16.000Z</published>
    <updated>2018-01-17T04:15:45.739Z</updated>
    
    <content type="html"><![CDATA[<p>使用蒙板可以让我们只关注感兴趣的图像部分。<br>掩码的关键点是它们允许我们将计算的重点仅限于感兴趣的图像区域.<br><img src="/images/PracPythonOpenCV6-1.png" width="200" height="300" title="图·1"><br><img src="/images/PracPythonOpenCV6-2.png" width="200" height="300" title="图·2"></p><p><blockquote>详细解释：<br><a href="https://docs.opencv.org/3.0-beta/modules/core/doc/operations_on_arrays.html?highlight=bitwise_and#cv2.bitwise_and" target="_blank" rel="noopener">https://docs.opencv.org/3.0-beta/modules/core/doc/operations_on_arrays.html?<br>highlight=bitwise_and#cv2.bitwise_and</a><br></blockquote><br><figure class="highlight python"><figcaption><span>蒙板</span><a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">masking.py</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">ap = argparse.ArgumentParser()</span><br><span class="line">ap.add_argument(<span class="string">"-i"</span>,<span class="string">"--image"</span>,required =<span class="keyword">True</span>, help=<span class="string">"Path to the image"</span>)</span><br><span class="line">args = vars(ap.parse_args())</span><br><span class="line"></span><br><span class="line">image = cv2.imread(args[<span class="string">"image"</span>])</span><br><span class="line">cv2.imshow(<span class="string">"Original"</span>,image)</span><br><span class="line"></span><br><span class="line">mask = np.zeros(image.shape[:<span class="number">2</span>],dtype =<span class="string">"uint8"</span>)</span><br><span class="line">(cx,cy) = (image.shape[<span class="number">1</span>]//<span class="number">2</span>,image.shape[<span class="number">0</span>]//<span class="number">2</span>)</span><br><span class="line">cv2.rectangle(mask,(cx<span class="number">-250</span>,cy<span class="number">-150</span>),(cx+<span class="number">200</span> ,cy+<span class="number">150</span>),<span class="number">255</span>,<span class="number">-1</span>)</span><br><span class="line">cv2.imshow(<span class="string">"Mask"</span>,mask)</span><br><span class="line"></span><br><span class="line">masked = cv2.bitwise_and(image,image,mask=mask)</span><br><span class="line"><span class="comment">#bitwise_and方法前两个参数是图像本身</span></span><br><span class="line">掩码只考虑掩码大于零的原始图像中的像素</span><br><span class="line">cv2.imshow(<span class="string">"Mask applied to image"</span>,masked)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mask = np.zeros(image.shape[:<span class="number">2</span>], dtype = <span class="string">"uint8"</span>)</span><br><span class="line">cv2.circle(mask, (cx, cy), <span class="number">100</span>, <span class="number">255</span>, <span class="number">-1</span>)</span><br><span class="line">masked = cv2.bitwise_and(image, image, mask = mask)</span><br><span class="line">cv2.imshow(<span class="string">"Mask"</span>, mask)</span><br><span class="line">cv2.imshow(<span class="string">"Mask Applied to Image"</span>, masked)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用蒙板可以让我们只关注感兴趣的图像部分。&lt;br&gt;掩码的关键点是它们允许我们将计算的重点仅限于感兴趣的图像区域.&lt;br&gt;&lt;img src=&quot;/images/PracPythonOpenCV6-1.png&quot; width=&quot;200&quot; height=&quot;300&quot; title=&quot;图·
      
    
    </summary>
    
      <category term="opencv" scheme="https://harveyyeung.github.io/categories/opencv/"/>
    
    
      <category term="opencv" scheme="https://harveyyeung.github.io/tags/opencv/"/>
    
      <category term="python" scheme="https://harveyyeung.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>opencv入门5:按位操作-bitwise operations</title>
    <link href="https://harveyyeung.github.io/2018/01/15/PracPythonOpenCV5/"/>
    <id>https://harveyyeung.github.io/2018/01/15/PracPythonOpenCV5/</id>
    <published>2018-01-15T02:42:48.000Z</published>
    <updated>2018-01-17T04:11:43.492Z</updated>
    
    <content type="html"><![CDATA[<p>现在我们将回顾四个按位运算：AND，OR，XOR和NOT。这四个操作虽然非常基础和低级，但对于图像处理至关重要，特别是当我们在6节开始使用蒙版时。</p><p>按位操作以二进制方式操作，并以灰度图像表示:</p><figure class="highlight python"><figcaption><span>按位操作</span><a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">bitwise.py</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">rectangle = np.zeros((<span class="number">300</span>,<span class="number">300</span>),dtype=<span class="string">"uint8"</span>)</span><br><span class="line">cv2.rectangle(rectangle,(<span class="number">25</span>,<span class="number">25</span>),(<span class="number">275</span>,<span class="number">275</span>),<span class="number">255</span>,<span class="number">-1</span>)</span><br><span class="line">cv2.imshow(<span class="string">"Rectangle"</span>,rectangle)</span><br><span class="line"></span><br><span class="line">circle = np.zeros((<span class="number">300</span>,<span class="number">300</span>),dtype=<span class="string">"uint8"</span>)</span><br><span class="line">cv2.circle(circle,(<span class="number">150</span>,<span class="number">150</span>),<span class="number">150</span>,<span class="number">255</span>,<span class="number">-1</span>)</span><br><span class="line">cv2.imshow(<span class="string">"Circle"</span>,circle)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">bitwiseAnd = cv2.bitwise_and(rectangle,circle)</span><br><span class="line">cv2.imshow(<span class="string">"And"</span>,bitwiseAnd)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">bitwiseOr = cv2.bitwise_or(rectangle,circle)</span><br><span class="line">cv2.imshow(<span class="string">"OR"</span>,bitwiseOr)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">bitwiseXor = cv2.bitwise_xor(rectangle,circle)</span><br><span class="line">cv2.imshow(<span class="string">"XOR"</span>,bitwiseXor)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">bitwiseNot = cv2.bitwise_not(rectangle)</span><br><span class="line">cv2.imshow(<span class="string">"Not"</span>,bitwiseNot)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>  <blockquote><br># 1. AND: A bitwise AND is true if and only if both pixels<br># are greater than zero.<br># 2. OR: A bitwise OR is true if either of the two pixels<br># are greater than zero.<br># 3. XOR: A bitwise XOR is true if and only if either of the<br># two pixels are greater than zero, but not both.<br># 4. NOT: A bitwise NOT inverts the “on” and “off” pixels<br># in an image.<br></blockquote><br>运行结果如下:<br><img src="/images/PracPythonOpenCV5-1.png" width="200" height="300" title="图·1"><br><img src="/images/PracPythonOpenCV5-2.png" width="200" height="300" title="图·2"><br><img src="/images/PracPythonOpenCV5-3.png" width="200" height="300" title="图·3"><br><img src="/images/PracPythonOpenCV5-4.png" width="200" height="300" title="图·4"><br><img src="/images/PracPythonOpenCV5-5.png" width="200" height="300" title="图·5"><br><br><br><br>如果一个给定的像素的值大于零，那么这个像素会被打开，如果它的值为零，它就会被关闭。按位功能在这些二进制条件下运行。<br>1. AND：当且仅当两个像素都大于零时，按位AND才为真。<br>2. OR：如果两个像素中的任何一个大于零，则按位“或”为真。<br>3. XOR 异或功能：当且仅当两个像素中的任何一个大于零时，按位XOR才为真，但不是两者都是。当且仅当两个像素一个大于0一个小于0时才为真，其他都为false<br>4. NOT 取反：倒置图像中的“开”和“关”像素。<br><br><br><blockquote class="blockquote-center">来是偶然，去是必然，尽其当然，顺其自然。</blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在我们将回顾四个按位运算：AND，OR，XOR和NOT。这四个操作虽然非常基础和低级，但对于图像处理至关重要，特别是当我们在6节开始使用蒙版时。&lt;/p&gt;
&lt;p&gt;按位操作以二进制方式操作，并以灰度图像表示:&lt;/p&gt;
&lt;figure class=&quot;highlight pyth
      
    
    </summary>
    
      <category term="opencv" scheme="https://harveyyeung.github.io/categories/opencv/"/>
    
    
      <category term="opencv" scheme="https://harveyyeung.github.io/tags/opencv/"/>
    
      <category term="python" scheme="https://harveyyeung.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>opencv入门4:图像算术-image arithmetic</title>
    <link href="https://harveyyeung.github.io/2018/01/12/PracPythonOpenCV4/"/>
    <id>https://harveyyeung.github.io/2018/01/12/PracPythonOpenCV4/</id>
    <published>2018-01-12T03:39:06.000Z</published>
    <updated>2018-01-12T03:54:28.561Z</updated>
    
    <content type="html"><![CDATA[<p>RGB的像素值都在[0,255],如果我们想给一个250的像素再加十个像素会怎么样？</p><p>NumPy将执行模算术和“环绕”。比如250 再加10像素，会绕回到4，<br>OpenCV 将执行剪切并确保像素值永远不会超出范围[0,255]</p><blockquote><br>NumPy will perform modulo arithmetic and “wrap around”.<br>OpenCV, on the other hand, will perform clipping and ensure pixel values never fall outside the range [0, 255].<br></blockquote><figure class="highlight python"><figcaption><span>像素算术</span><a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">arithmetic.py</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">ap = argparse.ArgumentParser()</span><br><span class="line">ap.add_argument(<span class="string">"-i"</span>,<span class="string">"--image"</span>,required =<span class="keyword">True</span>, help=<span class="string">"Path to the image"</span>)</span><br><span class="line">args = vars(ap.parse_args())</span><br><span class="line"></span><br><span class="line">image = cv2.imread(args[<span class="string">"image"</span>])</span><br><span class="line">cv2.imshow(<span class="string">"Original"</span>,image)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"max of 255:&#123;&#125;"</span>.format(cv2.add(np.uint8([<span class="number">200</span>]),np.uint8([<span class="number">100</span>]))))</span><br><span class="line">print(<span class="string">"min of 0:&#123;&#125;"</span>.format(cv2.subtract(np.uint8([<span class="number">50</span>]),np.uint8([<span class="number">100</span>]))))</span><br><span class="line"></span><br><span class="line">print(<span class="string">"wrap around :&#123;&#125;"</span>.format(np.uint8([<span class="number">200</span>])+np.uint8([<span class="number">100</span>])))</span><br><span class="line">print(<span class="string">"wrap around :&#123;&#125;"</span>.format(np.uint8([<span class="number">50</span>])-np.uint8([<span class="number">100</span>])))</span><br></pre></td></tr></table></figure>  <p>运行结果如下:<br><img src="/images/PracPythonOpenCV4-1.png" width="200" height="300" title="图·1"></p><figure class="highlight python"><figcaption><span>像素算术</span><a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">arithmetic.py</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">M =np.ones(image.shape, dtype=<span class="string">"uint8"</span>)*<span class="number">100</span></span><br><span class="line"><span class="comment"># defines a NumPy array of ones, with the same</span></span><br><span class="line"><span class="comment"># size as our image.</span></span><br><span class="line"><span class="comment">#为了用100的值而不是1来填充我们的矩阵，我们简单地把1的矩阵乘以100。</span></span><br><span class="line">added = cv2.add(image,M)</span><br><span class="line">cv2.imshow(<span class="string">"Added"</span>,added)</span><br><span class="line"></span><br><span class="line">M = np.ones(image.shape,dtype =<span class="string">"uint8"</span>)*<span class="number">50</span></span><br><span class="line">subtracted = cv2.subtract(image,M)</span><br><span class="line">cv2.imshow(<span class="string">"Subtraced"</span>,subtracted)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>  <img src="/images/PracPythonOpenCV4-2.png" width="200" height="300" title="图·2"><blockquote class="blockquote-center">一件事情的毕业，永远是另一件事情的开启.</blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;RGB的像素值都在[0,255],如果我们想给一个250的像素再加十个像素会怎么样？&lt;/p&gt;
&lt;p&gt;NumPy将执行模算术和“环绕”。比如250 再加10像素，会绕回到4，&lt;br&gt;OpenCV 将执行剪切并确保像素值永远不会超出范围[0,255]&lt;/p&gt;
&lt;blockquo
      
    
    </summary>
    
      <category term="opencv" scheme="https://harveyyeung.github.io/categories/opencv/"/>
    
    
      <category term="opencv" scheme="https://harveyyeung.github.io/tags/opencv/"/>
    
      <category term="python" scheme="https://harveyyeung.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>opencv入门3:图片操作-image transformations</title>
    <link href="https://harveyyeung.github.io/2018/01/09/PracPythonOpenCV3/"/>
    <id>https://harveyyeung.github.io/2018/01/09/PracPythonOpenCV3/</id>
    <published>2018-01-09T09:32:08.000Z</published>
    <updated>2018-01-10T03:01:26.465Z</updated>
    
    <content type="html"><![CDATA[<blockquote>如opencv开发前的准备工作中所说,此系列文章是在学习<a href="https://jackmk.ctfile.com/fs/14155983-233384097" target="_blank" rel="noopener">Practical Python and OpenCV</a>(<a href="https://jackmk.ctfile.com/fs/14155983-233384097" target="_blank" rel="noopener">点击下载</a>)这本书的一些记录,发出来的文章跳过了第三章对RGB,以及numpy简单操作等介绍，请大家下载原书查看，在原书中对一下段落已进行翻译注释。文章系列完整展示代码<a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">点击下载</a></blockquote><h3 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h3><figure class="highlight python"><figcaption><span>平移</span><a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">translation.py</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> imutils</span><br><span class="line">ap = argparse.ArgumentParser()</span><br><span class="line">ap.add_argument(<span class="string">"-i"</span>, <span class="string">"--image"</span>, required = <span class="keyword">True</span>, </span><br><span class="line">    help =<span class="string">"Path to the image"</span>)</span><br><span class="line">args = vars(ap.parse_args())</span><br><span class="line"></span><br><span class="line">image = cv2.imread(args[<span class="string">"image"</span>])</span><br><span class="line">cv2.imshow(<span class="string">"Original"</span>, image)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">M = np.float32([[<span class="number">1</span>,<span class="number">0</span>,<span class="number">25</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">50</span>]])</span><br><span class="line"><span class="comment">#定义我们的平移矩阵M</span></span><br><span class="line"><span class="comment">#矩阵M被定义为一个浮点数组 - 这很重要，因为OpenCV期望这个矩阵是浮点类型的。</span></span><br><span class="line"><span class="comment">#矩阵的第一行是[1,0，tx]，其中tx是像素的数量，我们将左右移动图像。</span></span><br><span class="line"><span class="comment">#tx的负值会将图像左移，正值会将图像向右移</span></span><br><span class="line"><span class="comment">#我们将矩阵的第二行定义为[0，1，ty]，其中ty是我们将向上或向下移动图像的像素数量。</span></span><br><span class="line"><span class="comment">#ty的负值会使图像向上移动，正值会使图像向下移动。</span></span><br><span class="line">shifted =cv2.warpAffine(image ,M ,(image.shape[<span class="number">1</span>], image.shape[<span class="number">0</span>]))</span><br><span class="line"><span class="comment">#warpAffine第一个参数是我们想要移动的图像，第二个参数是我们的平移矩阵M.最后，我们手动提供图像的尺寸（宽度和高度）作为第三个参数</span></span><br><span class="line">cv2.imshow(<span class="string">"Shifted Up and Left"</span>,shifted)</span><br><span class="line"></span><br><span class="line">M = np.float32([[<span class="number">1</span>,<span class="number">0</span>,<span class="number">-50</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">-90</span>]])</span><br><span class="line">shifted =cv2.warpAffine(image ,M ,(image.shape[<span class="number">1</span>], image.shape[<span class="number">0</span>]))</span><br><span class="line">cv2.imshow(<span class="string">"Shifted Up and Left"</span>,shifted)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>  <p>以上多次使用warpAffine重复性很高而且 使用起来不方便，我们可以定义一个叫imutils.py的模块封装这个方法如下：</p><figure class="highlight python"><figcaption><span>工具类</span><a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">imutils.py</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">translate</span><span class="params">(image, x, y)</span>:</span></span><br><span class="line">    M = np.float32([[<span class="number">1</span>, <span class="number">0</span>, x], [<span class="number">0</span>, <span class="number">1</span>, y]])</span><br><span class="line">    shifted = cv2.warpAffine(image, M, (image.shape[<span class="number">1</span>], image.shape[<span class="number">0</span>]))</span><br><span class="line">    <span class="keyword">return</span> shifted</span><br></pre></td></tr></table></figure> <p>再实现上面平移的动作:</p><figure class="highlight python"><figcaption><span>平移</span><a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">translation.py</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> imutils</span><br><span class="line"><span class="comment">#使用imutils中“convenience”方法来完成平移，旋转和调整大小等常见任务。</span></span><br><span class="line">ap = argparse.ArgumentParser()</span><br><span class="line">ap.add_argument(<span class="string">"-i"</span>, <span class="string">"--image"</span>, required = <span class="keyword">True</span>, </span><br><span class="line">    help =<span class="string">"Path to the image"</span>)</span><br><span class="line">args = vars(ap.parse_args())</span><br><span class="line"></span><br><span class="line">image = cv2.imread(args[<span class="string">"image"</span>])</span><br><span class="line">cv2.imshow(<span class="string">"Original"</span>, image)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">shifted =imutils.translate(image,<span class="number">0</span>,<span class="number">100</span>)</span><br><span class="line">cv2.imshow(<span class="string">"Shifted Up and Left"</span>,shifted)</span><br><span class="line"></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure> <h3 id="Rotation-旋转一个角度q的图像。"><a href="#Rotation-旋转一个角度q的图像。" class="headerlink" title="Rotation 旋转一个角度q的图像。"></a>Rotation 旋转一个角度q的图像。</h3><figure class="highlight python"><figcaption><span>旋转</span><a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">rotate.py</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> imutils</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">ap = argparse.ArgumentParser()</span><br><span class="line">ap.add_argument(<span class="string">"-i"</span>,<span class="string">"--image"</span>,required =<span class="keyword">True</span>,help =<span class="string">"Path to the image"</span>)</span><br><span class="line">args =vars(ap.parse_args())</span><br><span class="line"></span><br><span class="line">image = cv2.imread(args[<span class="string">"image"</span>])</span><br><span class="line">cv2.imshow(<span class="string">"Original"</span>,image)</span><br><span class="line"></span><br><span class="line">(h,w) = image.shape[:<span class="number">2</span>]</span><br><span class="line">center = (w//<span class="number">2</span>,h//<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">M = cv2.getRotationMatrix2D(center, <span class="number">45</span> , <span class="number">1.0</span>)</span><br><span class="line"><span class="comment">#cv2.getRotationMatrix2D(center, degrees , scale)</span></span><br><span class="line"><span class="comment">#center为需要围绕旋转的点，当我们旋转图像时，我们需要指定我们要旋转的点。</span></span><br><span class="line"><span class="comment">#在大多数情况下，你会想要围绕图像的中心旋转;然而，</span></span><br><span class="line"><span class="comment">#OpenCV允许你指定你想旋转的任意点</span></span><br><span class="line"><span class="comment"># degrees 旋转的角度</span></span><br><span class="line"><span class="comment"># scale 比例 这里你可以指定一个浮点值，其中1.0意味着使用相同的图像转换。但是，如果您指定的值为2.0，则图像的大小将加倍。类似地，0.5的值将图像的大小减半。</span></span><br><span class="line"><span class="comment">#就像我们定义矩阵来翻译图像一样，我们也定义了一个矩阵来旋转图像。我们只需要调用cv2.getRotationMatrix2D方法，而不是使用NumPy手工构造矩阵</span></span><br><span class="line">rotated = cv2.warpAffine(image, M,(w,h))</span><br><span class="line">cv2.imshow(<span class="string">"Rotated by 45 Degrees"</span>, rotated)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">M = cv2.getRotationMatrix2D(center, <span class="number">-90</span>,<span class="number">1.0</span>)</span><br><span class="line">rotated = cv2.warpAffine(image, M ,(w,h))</span><br><span class="line">cv2.imshow(<span class="string">"Rotated by -90 Degrees"</span>,rotated)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rotated = imutils.rotate(image,<span class="number">60</span>,<span class="keyword">None</span>,<span class="number">0.5</span>)</span><br><span class="line">cv2.imshow(<span class="string">"Rotated by imutils"</span>,rotated)</span><br><span class="line"></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure> <p>封装rotate方法<br><figure class="highlight python"><figcaption><span>工具类</span><a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">imutils.py</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(image, angle ,center= None,scale = <span class="number">1.0</span>)</span>:</span></span><br><span class="line">    (h,w)= image.shape[:<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">if</span> center <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        center =(w /<span class="number">2</span>,h/<span class="number">2</span>)</span><br><span class="line">    M = cv2.getRotationMatrix2D(center,angle,scale)</span><br><span class="line">    rotated = cv2.warpAffine(image, M ,(w,h))</span><br><span class="line">    <span class="keyword">return</span> rotated</span><br></pre></td></tr></table></figure><br>调用方式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rotated = imutils.rotate(image,60,None,0.5)</span><br></pre></td></tr></table></figure><h3 id="resize-调整大小"><a href="#resize-调整大小" class="headerlink" title="resize 调整大小"></a>resize 调整大小</h3><figure class="highlight python"><figcaption><span>调整大小</span><a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">resize.py</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> imutils</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">ap = argparse.ArgumentParser()</span><br><span class="line">ap.add_argument(<span class="string">"-i"</span>,<span class="string">"--image"</span>,required = <span class="keyword">True</span>,help = <span class="string">"Path to the image"</span>)</span><br><span class="line"></span><br><span class="line">args = vars(ap.parse_args())</span><br><span class="line"></span><br><span class="line">image = cv2.imread(args[<span class="string">"image"</span>])</span><br><span class="line">cv2.imshow(<span class="string">"Original"</span>,image)</span><br><span class="line"></span><br><span class="line">r = <span class="number">150.0</span> /image.shape[<span class="number">1</span>]</span><br><span class="line"><span class="comment">#定义新图片的宽度为150，为了计算新图片的高度，计算出新图片宽度和当前图片宽度的比例。</span></span><br><span class="line">dim = (<span class="number">150</span>,int(image.shape[<span class="number">0</span>]*r))</span><br><span class="line"><span class="comment">#新图片的宽高</span></span><br><span class="line">resized = cv2.resize(image , dim, interpolation = cv2.INTER_AREA)</span><br><span class="line"></span><br><span class="line"><span class="comment">#cv2.resize(image,dim,interpolation)  </span></span><br><span class="line"><span class="comment">#image 需要调整的图片    dim 新图片的尺寸 </span></span><br><span class="line"><span class="comment">#最后一个参数是我们的插值方法，它是在幕后处理实际图像大小调整的算法</span></span><br><span class="line"><span class="comment">#cv2.INTER_AREA，cv2.INTER_LINEAR,cv2.INTER_CUBIC,cv2.INTER_NEAREST</span></span><br><span class="line"><span class="comment"># interpolation 可选参数</span></span><br><span class="line"><span class="comment"># INTER_NEAREST - a nearest-neighbor interpolation</span></span><br><span class="line"><span class="comment"># INTER_LINEAR - a bilinear interpolation (used by default)</span></span><br><span class="line"><span class="comment"># INTER_AREA - resampling using pixel area relation. It may be a preferred method for image decimation, as it gives moire’-free results. But when the image is zoomed, it is similar to the INTER_NEAREST method.</span></span><br><span class="line"><span class="comment"># INTER_CUBIC - a bicubic interpolation over 4x4 pixel neighborhood</span></span><br><span class="line"><span class="comment"># INTER_LANCZOS4 - a Lanczos interpolation over 8x8 pixel neighborhood</span></span><br><span class="line">NTER_NEAREST - 最近邻居插值</span><br><span class="line">INTER_LINEAR - 双线性插值（默认使用）</span><br><span class="line">INTER_AREA - 使用像素区域关系重采样。这可能是图像抽取的首选方法，因为它可以产生无莫尔效应的结果。但是当图像放大时，它与INTER_NEAREST方法类似。 </span><br><span class="line">INTER_CUBIC - <span class="number">4</span>x4像素邻域上的双三次插值</span><br><span class="line">INTER_LANCZOS4 - <span class="number">8</span>x8像素邻域上的Lanczos插值</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">"resized(width)"</span>,resized)</span><br><span class="line"></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure> <h3 id="Flipping-旋转"><a href="#Flipping-旋转" class="headerlink" title="Flipping 旋转"></a>Flipping 旋转</h3><p>我们可以在x或y轴周围翻转图像，甚至可以翻转图像（We can flip an image around either the x or y axis, or even both.）<br><figure class="highlight python"><figcaption><span>旋转</span><a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">flipping.py</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">ap = argparse.ArgumentParser()</span><br><span class="line">ap.add_argument(<span class="string">"-i"</span>,<span class="string">"--image"</span>,required = <span class="keyword">True</span>,help =<span class="string">"Path to the image"</span>)</span><br><span class="line">args = vars(ap.parse_args())</span><br><span class="line"></span><br><span class="line">image = cv2.imread(args[<span class="string">"image"</span>])</span><br><span class="line">cv2.imshow(<span class="string">"Original"</span>,image)</span><br><span class="line"></span><br><span class="line">flipped = cv2.flip(image,<span class="number">1</span>)</span><br><span class="line">cv2.imshow(<span class="string">"Flipped Horizontally"</span>,flipped)</span><br><span class="line"><span class="comment">#使用1的翻转代码值表示我们将水平地围绕y轴翻转图像。</span></span><br><span class="line"></span><br><span class="line">flipped = cv2.flip(image,<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 指定一个0的翻转代码表示我们想要垂直翻转图像，围绕X轴</span></span><br><span class="line">cv2.imshow(<span class="string">"Flipped Vertically"</span>,flipped)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flipped = cv2.flip(image,<span class="number">-1</span>)</span><br><span class="line"><span class="comment"># 使用负向翻转代码将图像翻转两个轴。</span></span><br><span class="line">cv2.imshow(<span class="string">"Flipped Horizontally&amp;Vertically"</span>,flipped)</span><br><span class="line"></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure> </p><h3 id="Cropping-裁剪"><a href="#Cropping-裁剪" class="headerlink" title="Cropping 裁剪"></a>Cropping 裁剪</h3><p>图片的裁剪使用NumPy数组切片来完成图像裁剪<br><figure class="highlight python"><figcaption><span>裁剪</span><a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">cropping.py</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">ap = argparse.ArgumentParser()</span><br><span class="line">ap.add_argument(<span class="string">"-i"</span>,<span class="string">"--image"</span>,required =<span class="keyword">True</span>, help=<span class="string">"Path to the image"</span>)</span><br><span class="line">args = vars(ap.parse_args())</span><br><span class="line"></span><br><span class="line">image = cv2.imread(args[<span class="string">"image"</span>])</span><br><span class="line">cv2.imshow(<span class="string">"Original"</span>,image)</span><br><span class="line"><span class="comment">#NumPy数组中高度在前面，宽度在后面</span></span><br><span class="line">cropped = image[<span class="number">30</span>:<span class="number">220</span> ,<span class="number">10</span>:<span class="number">335</span>]</span><br><span class="line"><span class="comment">#所以我们需要截取的区域值定义需要按照numpy的格式，如上[starty:endy,startx:endx]</span></span><br><span class="line"><span class="comment"># 1.Start y: The starting y coordinate. In this case, we</span></span><br><span class="line"><span class="comment"># start at y = 30.</span></span><br><span class="line"><span class="comment"># 2. End y: The ending y coordinate. We will end our crop</span></span><br><span class="line"><span class="comment"># at y = 220.</span></span><br><span class="line"><span class="comment"># 3. Start x: The starting x coordinate of the slice. We start</span></span><br><span class="line"><span class="comment"># the crop at x = 10.</span></span><br><span class="line"><span class="comment"># 4. End x: The ending x-axis coordinate of the slice. Our</span></span><br><span class="line"><span class="comment"># slice ends at x = 335.</span></span><br><span class="line">cv2.imshow(<span class="string">"update"</span>,cropped)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure> </p><blockquote class="blockquote-center">凡事往简单处想，往认真处行。</blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;如opencv开发前的准备工作中所说,此系列文章是在学习&lt;a href=&quot;https://jackmk.ctfile.com/fs/14155983-233384097&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Practical P
      
    
    </summary>
    
      <category term="opencv" scheme="https://harveyyeung.github.io/categories/opencv/"/>
    
    
      <category term="opencv" scheme="https://harveyyeung.github.io/tags/opencv/"/>
    
      <category term="python" scheme="https://harveyyeung.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>opencv入门2:使用opencv简单画图</title>
    <link href="https://harveyyeung.github.io/2018/01/05/PracPythonOpenCV2/"/>
    <id>https://harveyyeung.github.io/2018/01/05/PracPythonOpenCV2/</id>
    <published>2018-01-05T07:23:38.000Z</published>
    <updated>2018-01-08T04:23:47.490Z</updated>
    
    <content type="html"><![CDATA[<blockquote>如opencv开发前的准备工作中所说,此系列文章是在学习<a href="https://jackmk.ctfile.com/fs/14155983-233384097" target="_blank" rel="noopener">Practical Python and OpenCV</a>(<a href="https://jackmk.ctfile.com/fs/14155983-233384097" target="_blank" rel="noopener">点击下载</a>)这本书的一些记录,发出来的文章跳过了第三章对RGB,以及numpy简单操作等介绍，请大家下载原书查看，在原书中对一下段落已进行翻译注释。文章系列完整展示代码<a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">点击下载</a></blockquote><h3 id="线和矩形"><a href="#线和矩形" class="headerlink" title="线和矩形"></a>线和矩形</h3><figure class="highlight python"><figcaption><span>画线</span><a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">drawing.py</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">canvas = np.zeros((<span class="number">300</span>, <span class="number">300</span>, <span class="number">3</span>), dtype = <span class="string">"uint8"</span>)</span><br><span class="line"><span class="comment">#使用np.zeros方法构造一个300，300，3通道的RGB的numpy array</span></span><br><span class="line"><span class="comment">#zeros方法用初始值为零填充数组中的每个元素。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#dtype 数据类型  8进制（</span></span><br><span class="line"><span class="comment">#Since we are representing our image as an RGB image with pixels in the range [0, 255], </span></span><br><span class="line"><span class="comment">#it’s important that we use an 8-bit unsigned integer, or uint8. There #are many </span></span><br><span class="line"><span class="comment">#other data types that we can use (common ones include 32-bit integers, and 32-bit </span></span><br><span class="line"><span class="comment">#or 64-bit floats), but we’ll mainly be using uint8 for the majority of the examples in this book）</span></span><br><span class="line"></span><br><span class="line">green = (<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>)   <span class="comment">#定义一个表示绿色的BGR元组</span></span><br><span class="line">cv2.line(canvas,(<span class="number">0</span>,<span class="number">0</span>),(<span class="number">300</span>,<span class="number">300</span>),green) </span><br><span class="line"><span class="comment">#line(canvas.point1,point2,color) 画布，起点，终点，颜色</span></span><br><span class="line"> </span><br><span class="line">cv2.imshow(<span class="string">"Canvas"</span>, canvas)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">red = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>)</span><br><span class="line">cv2.line(canvas,(<span class="number">300</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">300</span>),red,<span class="number">3</span>)</span><br><span class="line"><span class="comment">#line(canvas.point1,point2,color，thickness) 画布，起点，终点，颜色，线条宽度pixels</span></span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">"Canvas"</span>,canvas)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>  <p>运行结果如下:<br><img src="/images/PracPythonOpenCV2-1.png" width="200" height="300" title="图·1"></p><figure class="highlight python"><figcaption><span>画矩形</span><a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">drawing.py</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cv2.rectangle(canvas,(<span class="number">10</span>,<span class="number">10</span>),(<span class="number">60</span>,<span class="number">60</span>),green)</span><br><span class="line"><span class="comment">#rectangle(canvas,point1,point2,color)画布，起点，终点，颜色</span></span><br><span class="line">we are starting our rectangle at point (<span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line">We decide to end our rectangle at(<span class="number">60</span>, <span class="number">60</span>), </span><br><span class="line">defining a region of <span class="number">50</span> x <span class="number">50</span> pixels</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">"Canvas"</span>,canvas)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">cv2.rectangle(canvas,(<span class="number">50</span>,<span class="number">200</span>),(<span class="number">200</span>,<span class="number">225</span>),red,<span class="number">5</span>)</span><br><span class="line"><span class="comment">#rectangle(canvas,point1,point2,color,thickness) 画布，起点，终点，颜色，线条宽度pixels</span></span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">"Canvas"</span>,canvas)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>  <p>以上我们只绘制了一个矩形的轮廓，如何绘制一个填充满的矩形？<br>&emsp;&emsp;我们只需要通过设置厚度参数为：-1，如下<br><figure class="highlight python"><figcaption><span>填充矩形</span><a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">drawing.py</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">blue = (<span class="number">255</span>, <span class="number">0</span> , <span class="number">0</span>)</span><br><span class="line">cv2.rectangle(canvas,(<span class="number">200</span>,<span class="number">50</span>),(<span class="number">255</span>,<span class="number">125</span>),blue,<span class="number">-1</span>)</span><br><span class="line">cv2.imshow(<span class="string">"Canvas"</span>,canvas)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><br>运行结果如下:<br><img src="/images/PracPythonOpenCV2-2.png" width="200" height="300" title="图·2"></p><h3 id="圆"><a href="#圆" class="headerlink" title="圆"></a>圆</h3><figure class="highlight python"><figcaption><span>画圆</span><a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">drawing.py</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">canvas = np.zeros((<span class="number">300</span>,<span class="number">300</span>,<span class="number">3</span>),dtype = <span class="string">"uint8"</span>)</span><br><span class="line">(centerX,centerY) = (canvas.shape[<span class="number">1</span>] // <span class="number">2</span> ,canvas.shape[<span class="number">0</span>] //<span class="number">2</span>)</span><br><span class="line"><span class="comment">#图像canvas的高度可以在canvas.shape [0]和canvas.shape [1]的宽度中找到。shape [2]为图像channels</span></span><br><span class="line">white = (<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> r <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">175</span>,<span class="number">25</span>):</span><br><span class="line"><span class="comment"># range(start, stop[, step])</span></span><br><span class="line"><span class="comment"># 参数说明：</span></span><br><span class="line"><span class="comment"># start: 计数从 start 开始。默认是从 0 开始。例如range（5）等价于range（0， 5）;</span></span><br><span class="line"><span class="comment"># end: 计数到 end 结束，但不包括 end。例如：range（0， 5） 是[0, 1, 2, 3, 4]没有5</span></span><br><span class="line"><span class="comment"># step：步长，默认为1。例如：range（0， 5） 等价于 range(0, 5, 1)</span></span><br><span class="line">     cv2.circle(canvas,(centerX,centerY),r,white)</span><br><span class="line"><span class="comment"># cv2.circle(canvas,(centerX,centerY),radius,color,thickness) 画布，起点，终点，颜色，线条宽度(为-1时填充整个图像)</span></span><br></pre></td></tr></table></figure> <p>运行结果如下:<br><img src="/images/PracPythonOpenCV2-3.png" width="200" height="300" title="图·3"></p><p>画一个半径，中心点随机的填充多圆图<br><figure class="highlight python"><figcaption><span>画圆</span><a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">drawing.py</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">25</span>):</span><br><span class="line">    radius = np.random.randint(<span class="number">5</span>, high =<span class="number">200</span>)</span><br><span class="line"> 使用np.random.randint 生成一个<span class="number">5</span>到<span class="number">200</span>之间的随机数</span><br><span class="line">    color = np.random.randint(<span class="number">0</span>, high =<span class="number">256</span>,size=(<span class="number">3</span>,)).tolist()</span><br><span class="line">    pt = np.random.randint(<span class="number">0</span>, high=<span class="number">300</span>, size = (<span class="number">2</span>,))</span><br><span class="line">    cv2.circle(canvas,tuple(pt),radius,color,<span class="number">-1</span>)</span><br><span class="line">cv2.imshow(<span class="string">"Canvas"</span>,canvas)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><br>运行结果如下:<br><img src="/images/PracPythonOpenCV2-4.png" width="200" height="300" title="图·4"></p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.random.randint(low, high=None, size=None, dtype=<span class="string">'l'</span>)</span><br></pre></td></tr></table></figure><div class="note "><p>Return random integers from low (inclusive) to high (exclusive).<br>Return random integers from the “discrete uniform” distribution of the specified dtype in the “half-open” interval [low, high). If high is None (the default), then results are from [0, low).</p></div><p>Parameters:</p><ul><li>low : intLowest (signed) integer to be drawn from the distribution (unless high=None, in which case this parameter is one above the highest such integer).</li><li>high : int, optionalIf provided, one above the largest (signed) integer to be drawn from the distribution (see above for behavior if high=None).</li><li>size : int or tuple of ints, optionalOutput shape. If the given shape is, e.g., (m, n, k), then m <em> n </em> k samples are drawn. Default is None, in which case a single value is returned.</li><li>dtype : dtype, optionalDesired dtype of the result. All dtypes are determined by their name, i.e., ‘int64’, ‘int’, etc, so byteorder is not available and a specific precision may have different C types depending on the platform. The default value is ‘np.int’.New in version 1.11.0.</li></ul><p>Returns: </p><ul><li>out : int or ndarray of intssize-shaped array of random integers from the appropriate distribution, or a single such random int if size not provided.</li></ul><blockquote class="blockquote-center" "荀子·修身"="">道虽迩，不行不至；事虽小，不为不成</blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;如opencv开发前的准备工作中所说,此系列文章是在学习&lt;a href=&quot;https://jackmk.ctfile.com/fs/14155983-233384097&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Practical P
      
    
    </summary>
    
      <category term="opencv" scheme="https://harveyyeung.github.io/categories/opencv/"/>
    
    
      <category term="opencv" scheme="https://harveyyeung.github.io/tags/opencv/"/>
    
      <category term="python" scheme="https://harveyyeung.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>opencv入门1:opencv开发前的准备工作</title>
    <link href="https://harveyyeung.github.io/2018/01/05/PracPythonOpenCV1/"/>
    <id>https://harveyyeung.github.io/2018/01/05/PracPythonOpenCV1/</id>
    <published>2018-01-05T05:36:34.000Z</published>
    <updated>2018-01-08T04:15:47.861Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/practicalpythonopencv.png" width="200" height="300"><p>这是我在学习<a href="https://jackmk.ctfile.com/fs/14155983-233384097" target="_blank" rel="noopener">Practical Python and OpenCV</a>(<a href="https://jackmk.ctfile.com/fs/14155983-233384097" target="_blank" rel="noopener">点击下载</a>)这本书的一些记录。计算机视觉的目标是理解图片中展示的内容。为了探索计算机视觉的世界，我们首先需要安装一些软件包和库。作为计算机视觉的初学者，安装其中一些软件包（特别是OpenCV）可能非常繁琐，具体取决于您使用的操作系统。如果遇到问题，请务必查阅软件包的网站以获取最新的安装说明。强烈建议您使用pip来管理软件包的安装。</p><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><p>&emsp;&emsp;在搭建环境的开始，首先确保你已经安装了python.如何安装请看： <a href="http://www.runoob.com/python/python-install.html" target="_blank" rel="noopener">http://www.runoob.com/python/python-install.html</a></p><h3 id="opencv"><a href="#opencv" class="headerlink" title="opencv"></a><a href="http://opencv.org/" target="_blank" rel="noopener">opencv</a></h3><p>&emsp;&emsp;如果NumPy的主要目标是大型高效的多维数组表示，那么OpenCV的主要目标就是实时图像处理,书中作者收集了PyImageSearch上各种Python版本和操作系统的OpenCV安装教程,<a href="https://www.pyimagesearch.com/opencv-tutorials-resources-guides/" target="_blank" rel="noopener">教程地址</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install opencv-python <span class="comment">#安装Opencv-python 的命令</span></span><br></pre></td></tr></table></figure><h3 id="numpy-和-scipy"><a href="#numpy-和-scipy" class="headerlink" title="numpy 和 scipy"></a><a href="http://www.numpy.org/" target="_blank" rel="noopener">numpy</a> 和 <a href="https://www.scipy.org/" target="_blank" rel="noopener">scipy</a></h3><p>&emsp;&emsp;<a href="http://www.numpy.org/" target="_blank" rel="noopener">numpy</a>是Python编程语言的一个库，为大型多维数组提供支持。使用numpy可以将图片转换为多维数组。将图像表示为NumPy数组在计算上和资源效率上表现优异，许多其他图像处理和机器学习库也使用NumPy数组表示。通过使用NumPy内置的高级数学函数，我们可以快速，方便地对图像进行数值分析。</p><p>&emsp;&emsp;<a href="https://www.scipy.org/" target="_blank" rel="noopener">scipy</a>是一个高级的科学计算库，它和Numpy联系很密切，Scipy一般都是操控Numpy数组来进行科学计算，所以可以说是基于Numpy之上了。Scipy有很多子模块可以应对不同的应用，例如插值运算，优化算法、图像处理、数学统计等。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pip install numpy <span class="comment">#安装numpy</span></span><br><span class="line">$ pip install scipy <span class="comment">#安装scipy</span></span><br></pre></td></tr></table></figure></p><h3 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a><a href="http://matplotlib.org/" target="_blank" rel="noopener">matplotlib</a></h3><p>&emsp;&emsp;<a href="http://matplotlib.org/" target="_blank" rel="noopener">matplotlib</a> 是一个绘图库。如果你以前曾经使用过MATLAB，那么在matplotlib环境中你可能会觉得很顺手。分析图像时，我们将使用matplotlib。无论是绘制图像直方图还是简单地查看图像本身，matplotlib都是您工具箱中的绝佳工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install matplotlib <span class="comment">#安装matplotlib</span></span><br></pre></td></tr></table></figure><h3 id="mahotas"><a href="#mahotas" class="headerlink" title="mahotas"></a><a href="http://mahotas.readthedocs.io/en/latest/#" target="_blank" rel="noopener">mahotas</a></h3><p>&emsp;&emsp;<a href="http://mahotas.readthedocs.io/en/latest/#" target="_blank" rel="noopener">mahotas</a> 就像OpenCV一样依赖于NumPy数组。在Mahotas中实现的许多功能都可以在OpenCV中找到，但在某些情况下，Mahotas接口更容易使用。我们将使用Mahotas来补充OpenCV。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install mathotas <span class="comment">#安装mathotas</span></span><br></pre></td></tr></table></figure><div class="note danger"><p>安装失败提示需要  Microsoft Visual C++ 14.0 is required.<br>在<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/#mahotas下载对应版本" target="_blank" rel="noopener">https://www.lfd.uci.edu/~gohlke/pythonlibs/#mahotas下载对应版本</a>,<br>执行pip install mathotas-1.4.0.cp<strong><em>*</em></strong>.whl  安装</p></div><h3 id="scikit-learn"><a href="#scikit-learn" class="headerlink" title="scikit-learn"></a><a href="http://scikit-learn.org/" target="_blank" rel="noopener">scikit-learn</a></h3><p>&emsp;&emsp;<a href="http://scikit-learn.org/" target="_blank" rel="noopener">scikit-learn</a> 是机器学习的算法和工具的集合</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install scikit-learn</span><br></pre></td></tr></table></figure><h3 id="scikit-image"><a href="#scikit-image" class="headerlink" title="scikit-image"></a><a href="http://scikit-image.org/" target="_blank" rel="noopener">scikit-image</a></h3><p><a href="http://scikit-image.org/" target="_blank" rel="noopener">scikit-image</a>  是图像处理算法的集合<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install -U scikit-image</span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&emsp;&emsp;此书需要的包都安装完毕了，以上使用到的包在此<a href="https://www.scipy.org/about.html" target="_blank" rel="noopener">https://www.scipy.org/about.html</a>有罗列，有兴趣的朋友可以查看相关官网详细了解各包的具体使用方式和包含的方法.</p><div class="note warning"><p>如果有包安装失败建议在<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/" target="_blank" rel="noopener">python库</a>中找到对应的whl包，使用下载包在相关python 环境中执行 pip install …..whl</p></div><blockquote class="blockquote-center">凡事往简单处想，往认真处行</blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/images/practicalpythonopencv.png&quot; width=&quot;200&quot; height=&quot;300&quot;&gt;
&lt;p&gt;这是我在学习&lt;a href=&quot;https://jackmk.ctfile.com/fs/14155983-233384097&quot; ta
      
    
    </summary>
    
      <category term="opencv" scheme="https://harveyyeung.github.io/categories/opencv/"/>
    
    
      <category term="opencv" scheme="https://harveyyeung.github.io/tags/opencv/"/>
    
      <category term="python" scheme="https://harveyyeung.github.io/tags/python/"/>
    
  </entry>
  
</feed>
