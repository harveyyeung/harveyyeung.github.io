<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Harvey`s note</title>
  
  <subtitle>专注当前的任务，控制支出</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://harveyyeung.github.io/"/>
  <updated>2018-03-07T07:30:19.487Z</updated>
  <id>https://harveyyeung.github.io/</id>
  
  <author>
    <name>Harvey</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>opencv入门11:图像阀值-thresholding</title>
    <link href="https://harveyyeung.github.io/2018/02/01/PracPythonOpenCV/PracPythonOpenCV11/"/>
    <id>https://harveyyeung.github.io/2018/02/01/PracPythonOpenCV/PracPythonOpenCV11/</id>
    <published>2018-02-01T06:32:39.000Z</published>
    <updated>2018-03-07T07:30:19.487Z</updated>
    
    <content type="html"><![CDATA[<p>一个简单的阈值例子就是选择一个像素值p，然后将小于p的所有像素强度设置为零，并且将所有像素值大于p设置为255.以这种方式，我们能够创建图像的二进制表示。</p><h3 id="一、阈值化的类型："><a href="#一、阈值化的类型：" class="headerlink" title="一、阈值化的类型："></a>一、阈值化的类型：</h3><p>OpenCV中提供了阈值（threshold）函数： threshold 。这个函数有5种阈值化类型:</p><ul><li>cv2.THRESH_BINARY</li><li>cv2.THRESH_BINARY_INV</li><li>cv2.THRESH_TRUNC</li><li>cv2.THRESH_TOZERO</li><li>cv2.THRESH_TOZERO_INV</li></ul><p>为了解释阈值分割的过程，我们来看一个简单有关像素灰度的图片，该图如下。该图中的蓝色水平线代表着具体的一个阈值。<br><img src="/images/PracPythonOpenCV11-1.png" width="400" height="400" title="图·1"></p><h4 id="阈值类型1：二进制阈值化-cv2-THRESH-BINARY"><a href="#阈值类型1：二进制阈值化-cv2-THRESH-BINARY" class="headerlink" title="阈值类型1：二进制阈值化  cv2.THRESH_BINARY"></a>阈值类型1：二进制阈值化  cv2.THRESH_BINARY</h4><ul><li>该阈值化类型如下式所示:<img src="/images/PracPythonOpenCV11-eq1.png" width="400" height="400"></li><li>解释：在运用该阈值类型的时候，先要选定一个特定的阈值量，比如：125，这样，新的阈值产生规则可以解释为大于125的像素点的灰度值设定为最大值(如8位灰度值最大为255)，灰度值小于125的像素点的灰度值设定为0。   <img src="/images/PracPythonOpenCV11-2.png" width="400" height="400" title="图·2"></li></ul><h4 id="阈值类型2：反二进制阈值化-cv2-THRESH-BINARY-INV"><a href="#阈值类型2：反二进制阈值化-cv2-THRESH-BINARY-INV" class="headerlink" title="阈值类型2：反二进制阈值化 cv2.THRESH_BINARY_INV"></a>阈值类型2：反二进制阈值化 cv2.THRESH_BINARY_INV</h4><ul><li>该阈值化类型如下式所示:<img src="/images/PracPythonOpenCV11-eq2.png" width="400" height="400"></li><li>解释：该阈值化与二进制阈值化相似，先选定一个特定的灰度值作为阈值，不过最后的设定值相反。（在8位灰度图中，例如大于阈值的设定为0，而小于该阈值的设定为255）。  <img src="/images/PracPythonOpenCV11-3.png" width="400" height="400" title="图·3"></li></ul><h4 id="阈值类型3：截断阈值化-cv2-THRESH-TRUNC"><a href="#阈值类型3：截断阈值化-cv2-THRESH-TRUNC" class="headerlink" title="阈值类型3：截断阈值化 cv2.THRESH_TRUNC"></a>阈值类型3：截断阈值化 cv2.THRESH_TRUNC</h4><ul><li>该阈值化类型如下式所示:<img src="/images/PracPythonOpenCV11-eq3.png" width="400" height="400"></li><li>解释：同样首先需要选定一个阈值，图像中大于该阈值的像素点被设定为该阈值，小于该阈值的保持不变。（例如：阈值选取为125，那小于125的阈值不改变，大于125的灰度值（230）的像素点就设定为该阈值）。<img src="/images/PracPythonOpenCV11-4.png" width="400" height="400" title="图·4">  </li></ul><h4 id="阈值类型4：阈值化为0-cv2-THRESH-TOZERO"><a href="#阈值类型4：阈值化为0-cv2-THRESH-TOZERO" class="headerlink" title="阈值类型4：阈值化为0 cv2.THRESH_TOZERO"></a>阈值类型4：阈值化为0 cv2.THRESH_TOZERO</h4><ul><li>该阈值化类型如下式所示:<img src="/images/PracPythonOpenCV11-eq4.png" width="400" height="400"></li><li>解释：先选定一个阈值，然后对图像做如下处理：1 像素点的灰度值大于该阈值的不进行任何改变；2 像素点的灰度值小于该阈值的，其灰度值全部变为0。<img src="/images/PracPythonOpenCV11-5.png" width="400" height="400" title="图·5">    </li></ul><h4 id="阈值类型5：反阈值化为0-cv2-THRESH-TOZERO-INV"><a href="#阈值类型5：反阈值化为0-cv2-THRESH-TOZERO-INV" class="headerlink" title="阈值类型5：反阈值化为0 cv2.THRESH_TOZERO_INV"></a>阈值类型5：反阈值化为0 cv2.THRESH_TOZERO_INV</h4><ul><li>该阈值化类型如下式所示:<img src="/images/PracPythonOpenCV11-eq5.png" width="400" height="400"></li><li>解释：原理类似于0阈值，但是在对图像做处理的时候相反，即：像素点的灰度值小于该阈值的不进行任何改变，而大于该阈值的部分，其灰度值全部变为0。<img src="/images/PracPythonOpenCV11-6.png" width="400" height="400" title="图·6">    </li></ul><h3 id="二、simple-thresholding-简单的阈值方法："><a href="#二、simple-thresholding-简单的阈值方法：" class="headerlink" title="二、simple thresholding  简单的阈值方法："></a>二、simple thresholding  简单的阈值方法：</h3><p>应用简单的阈值方法需要人为干预。<br>我们必须指定一个阈值T.低于T的所有像素强度都被设置为0.而所有大于T的像素强度被设置为255。</p><p> <code>cv2.threshold( src_gray, dst, threshold_value, max_BINARY_value,threshold_type )</code></p><ul><li>src_gray: 输入的灰度图像的地址。</li><li>dst: 输出图像的地址。</li><li>threshold_value: 进行阈值操作时阈值的大小。</li><li>max_BINARY_value: 设定的最大灰度值（该参数运用在二进制与反二进制阈值操作中）。</li><li>threshold_type: 阈值的类型。从上面提到的5种中选择出的结果。<img src="/images/PracPythonOpenCV11-7.png" width="400" height="400" title="图·7">    <img src="/images/PracPythonOpenCV11-8.png" width="400" height="400" title="图·8">    </li></ul><h3 id="三、adaptive-thresholding-自适应阀值"><a href="#三、adaptive-thresholding-自适应阀值" class="headerlink" title="三、adaptive thresholding  自适应阀值"></a>三、adaptive thresholding  自适应阀值</h3><p>在前面的部分我们使用是全局阈值，整幅图像采用同一个数作为阈值。当时这种方法并不适应与所有情况，尤其是当同一幅图像上的不同部分的具有不同亮度时。这种情况下我们需要采用自适应阈值。此时的阈值是根据图像上的每一个小区域计算与其对应的阈值。因此在同一幅图像上的不同区域采用的是不同的阈值，从而使我们能在亮度不同的情况下得到更好的结果。    </p><p> <code>cv2.adaptiveThreshold（image,max_BINARY_value,Adaptive_Method,threshold_type,Block_Size,C)</code></p><ul><li>max_BINARY_value: 设定的最大灰度值（该参数运用在二进制与反二进制阈值操作中）。</li><li>threshold_type: 阈值的类型。从上面提到的5种中选择出的结果。</li></ul><p>  这种方法需要我们指定三个参数，返回值只有一个。</p><ul><li>Adaptive Method- 指定计算阈值的方法。<ul><li>cv2.ADPTIVE_THRESH_MEAN_C：阈值取自相邻区域的平<br>均值</li><li>cv2.ADPTIVE_THRESH_GAUSSIAN_C：阈值取值相邻区域<br>的加权和，权重为一个高斯窗口。</li></ul></li><li>Block Size - 邻域大小（用来计算阈值的区域大小）。表明我们要检查图像的11×11像素区域，而不是像在简单的阈值方法中那样尝试对图像进行全局阈值</li><li>C - 这就是是一个常数，阈值就等于的平均值或者加权平均值减去这个常数。我们提供一个简单的叫做C的参数。这个值是一个从平均值中减去的整数，使我们可以微调我们的阈值</li></ul><p>一般来说，在平均自适应阈值和高斯自适应阈值之间进行选择需要在您的最后进行一些实验。要改变的最重要的参数是邻域大小和C，即从平均值中减去的值。通过试验这个值，你将能够显着地改变你的阈值的结果。 </p><figure class="highlight python"><figcaption><span>图像阀值-thresholding</span><a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">adaptive_thresholding.py</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">ap = argparse.ArgumentParser()</span><br><span class="line">ap.add_argument(<span class="string">"-i"</span>,<span class="string">"--image"</span>,required =<span class="keyword">True</span>, help=<span class="string">"Path to the image"</span>)</span><br><span class="line">args = vars(ap.parse_args())</span><br><span class="line"></span><br><span class="line">image = cv2.imread(args[<span class="string">"image"</span>])</span><br><span class="line">image = cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)</span><br><span class="line">blured = cv2.GaussianBlur(image,(<span class="number">5</span>,<span class="number">5</span>),<span class="number">0</span>)</span><br><span class="line">cv2.imshow(<span class="string">"Image"</span>,image)</span><br><span class="line"></span><br><span class="line">thresh =cv2.adaptiveThreshold(blured, <span class="number">255</span> ,cv2.ADAPTIVE_THRESH_MEAN_C,cv2.THRESH_BINARY_INV,<span class="number">11</span>,<span class="number">4</span>)</span><br><span class="line">cv2.imshow(<span class="string">"mean thresh"</span>,thresh)</span><br><span class="line"></span><br><span class="line">thresh =cv2.adaptiveThreshold(blured, <span class="number">255</span> ,cv2.ADAPTIVE_THRESH_GAUSSIAN_C,cv2.THRESH_BINARY_INV,<span class="number">15</span>,<span class="number">3</span>)</span><br><span class="line">cv2.imshow(<span class="string">"GAUSSIAN thresh"</span>,thresh)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>) </span><br><span class="line"></span><br></pre></td></tr></table></figure>  <img src="/images/PracPythonOpenCV11-9.png" width="400" height="400" title="图·9">    <h3 id="四、Otsu’s-二值化-和-Riddler-Calvard"><a href="#四、Otsu’s-二值化-和-Riddler-Calvard" class="headerlink" title="四、Otsu’s 二值化 和 Riddler-Calvard"></a>四、Otsu’s 二值化 和 Riddler-Calvard</h3><p>在使用全局阈值时，我们就是随便给了一个数来做阈值，那我们怎么知道<br>我们选取的这个数的好坏呢？答案就是不停的尝试。如果是一副双峰图像（简<br>单来说双峰图像是指图像直方图中存在两个峰）呢？我们岂不是应该在两个峰<br>之间的峰谷选一个值作为阈值？这就是Otsu 二值化要做的。简单来说就是对<br>一副双峰图像自动根据其直方图计算出一个阈值。（对于非双峰图像，这种方法<br>得到的结果可能会不理想）。</p><p><code>mahotas.thresholding.otsu（） 和   mahotas.thresholding.rc（）</code></p><figure class="highlight python"><figcaption><span>otsu_and_riddler</span><a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">otsu_and_riddler.py</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> mahotas</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">ap = argparse.ArgumentParser()</span><br><span class="line">ap.add_argument(<span class="string">"-i"</span>,<span class="string">"--image"</span>,required =<span class="keyword">True</span>, help=<span class="string">"Path to the image"</span>)</span><br><span class="line">args = vars(ap.parse_args())</span><br><span class="line"></span><br><span class="line">image = cv2.imread(args[<span class="string">"image"</span>])</span><br><span class="line">image = cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)</span><br><span class="line">blurred = cv2.GaussianBlur(image,(<span class="number">5</span>,<span class="number">5</span>),<span class="number">0</span>)</span><br><span class="line">cv2.imshow(<span class="string">"Image"</span>,image)</span><br><span class="line"></span><br><span class="line">T = mahotas.thresholding.otsu(blurred)</span><br><span class="line"><span class="comment">#为了计算T的最优值，我们使用mahotas.thresholding包中的otsu函数</span></span><br><span class="line">print(<span class="string">"Otsu`s threshold:&#123;&#125;"</span>.format(T))</span><br><span class="line">thresh = image.copy()</span><br><span class="line">thresh[thresh&gt;T] = <span class="number">255</span></span><br><span class="line">thresh[thresh&lt;T] = <span class="number">0</span></span><br><span class="line">thresh = cv2.bitwise_not(thresh)</span><br><span class="line"><span class="comment"># 首先，我们制作灰度图像的副本，以便使图像达到阈值。</span></span><br><span class="line"><span class="comment"># 第20行然后使任何值大于T white，</span></span><br><span class="line"><span class="comment"># 而第21行将所有剩余的不是白色的像素变成黑色像素。</span></span><br><span class="line"><span class="comment"># 然后我们通过使用cv2.bitwise_not来反转我们的阈值。</span></span><br><span class="line"><span class="comment"># 这相当于在本章前面的例子中应用cv2.THRESH_BINARY_INV阈值类型。</span></span><br><span class="line">cv2.imshow(<span class="string">"Ostu"</span>,thresh)</span><br><span class="line"></span><br><span class="line">T = mahotas.thresholding.rc(blurred)</span><br><span class="line"><span class="comment"># 另一种方法找到最优值T 时要牢记Riddler-Calvard方法。</span></span><br><span class="line"><span class="comment"># 使用mahotas.thresholding中的rc函数</span></span><br><span class="line">print(<span class="string">"Riddler-Calvard:&#123;&#125;"</span>.format(T))</span><br><span class="line">thresh = image.copy()</span><br><span class="line">thresh[thresh&gt;T] = <span class="number">255</span></span><br><span class="line">thresh[thresh&lt;<span class="number">255</span>] = <span class="number">0</span></span><br><span class="line">thresh = cv2.bitwise_not(thresh)</span><br><span class="line">cv2.imshow(<span class="string">"Riddler-Calvard"</span>,thresh)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>  <img src="/images/PracPythonOpenCV11-eq6.png">    <img src="/images/PracPythonOpenCV11-10.png" title="图·10">    ]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个简单的阈值例子就是选择一个像素值p，然后将小于p的所有像素强度设置为零，并且将所有像素值大于p设置为255.以这种方式，我们能够创建图像的二进制表示。&lt;/p&gt;
&lt;h3 id=&quot;一、阈值化的类型：&quot;&gt;&lt;a href=&quot;#一、阈值化的类型：&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="opencv" scheme="https://harveyyeung.github.io/categories/opencv/"/>
    
    
      <category term="opencv" scheme="https://harveyyeung.github.io/tags/opencv/"/>
    
      <category term="python" scheme="https://harveyyeung.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>opencv入门10:平滑和模糊-SMOOTHING AND BLURRING</title>
    <link href="https://harveyyeung.github.io/2018/01/31/PracPythonOpenCV/PracPythonOpenCV10/"/>
    <id>https://harveyyeung.github.io/2018/01/31/PracPythonOpenCV/PracPythonOpenCV10/</id>
    <published>2018-01-31T03:23:26.000Z</published>
    <updated>2018-01-31T04:28:19.179Z</updated>
    
    <content type="html"><![CDATA[<p>blurring：图像中的每个像素都与其周围的像素强度混合在一起。这个邻域像素的“混合”成为我们模糊的像素。</p><p>事实上，如果图像首先被平滑或模糊，许多图像处理和计算机视觉功能，如阈值和边缘检测，性能会更好。</p><h3 id="一、平均-averaging"><a href="#一、平均-averaging" class="headerlink" title="一、平均-averaging"></a>一、平均-averaging</h3><p>我们要探索的第一个模糊方法是平均，<br>为了平均模糊图像，我们使用cv2.blur(image,kernel)<br>image是我们希望模糊的图片，kernel 希望模糊的颗粒度值</p><figure class="highlight python"><figcaption><span>平滑和模糊</span><a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">blurring.py</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">ap = argparse.ArgumentParser()</span><br><span class="line">ap.add_argument(<span class="string">"-i"</span>,<span class="string">"--image"</span>,required =<span class="keyword">True</span>, help=<span class="string">"Path to the image"</span>)</span><br><span class="line">args = vars(ap.parse_args())</span><br><span class="line"></span><br><span class="line">image = cv2.imread(args[<span class="string">"image"</span>])</span><br><span class="line">cv2.imshow(<span class="string">"Original"</span>,image)</span><br><span class="line"></span><br><span class="line">blurred =  np.hstack([cv2.blur(image,(<span class="number">3</span>,<span class="number">3</span>)),cv2.blur(image,(<span class="number">5</span>,<span class="number">5</span>)),cv2.blur(image,(<span class="number">7</span>,<span class="number">7</span>))])</span><br><span class="line">cv2.imshow(<span class="string">"Averaged"</span>,blurred)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>  <img src="/images/PracPythonOpenCV10-1.png" width="400" height="400" title="图·1"><h3 id="二、高斯-gaussian"><a href="#二、高斯-gaussian" class="headerlink" title="二、高斯-gaussian"></a>二、高斯-gaussian</h3><p>高斯模糊与平均模糊相似，但是不是使用简单的均值，而是使用加权平均值，其中靠近中心像素的邻近像素对平均值贡献更多的“权重”。<br>最终的结果是我们的图像比使用上一节中讨论的平均方法更不明显，但更自然地模糊了。<br><figure class="highlight python"><figcaption><span>平滑和模糊</span><a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">blurring.py</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">blurred =  np.hstack([cv2.GaussianBlur(image,(<span class="number">3</span>,<span class="number">3</span>),<span class="number">0</span>),cv2.GaussianBlur(image,(<span class="number">5</span>,<span class="number">5</span>),<span class="number">0</span>),cv2.GaussianBlur(image,(<span class="number">7</span>,<span class="number">7</span>),<span class="number">0</span>)])</span><br><span class="line"><span class="comment"># cv2.GaussianBlur(image,(3,3),0)</span></span><br><span class="line"><span class="comment">#需要指定高斯核的宽和高（必须是奇数）。以及高斯函数沿X，Y 方向的标准</span></span><br><span class="line"><span class="comment">#差。如果我们只指定了X 方向的的标准差，Y 方向也会取相同值</span></span><br><span class="line"><span class="comment"># 0 是指根据窗口大小（3,3）来计算高斯函数标准差</span></span><br><span class="line"><span class="comment"># 最后一个参数是在x轴方向上的标准偏差。通过设置这个值为0，我们正在指示OpenCV根据我们的内核大小自动计算它们</span></span><br><span class="line">cv2.imshow(<span class="string">"Gaussian"</span>,blurred)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>  </p><img src="/images/PracPythonOpenCV10-2.png" width="400" height="400" title="图·2"><h3 id="三、中值模糊"><a href="#三、中值模糊" class="headerlink" title="三、中值模糊"></a>三、中值模糊</h3><p>传统上，中值模糊方法在去除椒盐噪声时效果最好，<br>这种噪音听起来就像是想象一样：想象一下把照片放在餐桌上，然后撒上盐和胡椒。使用中值模糊方法，您可以从图像中去除盐和胡椒粉。</p><p>当应用中值模糊时，我们首先定义我们的内核大小k。然后，如在平均模糊方法中，我们考虑大小为k * k的邻域中的所有像素。但是，与平均方法不同，不是用邻域的平均值替换中心像素，而是用邻域的中值代替中心像素。(When applying a median blur, we first define our kernel size k. Then, as in the averaging blurring method, we consider all pixels in the neighborhood of size k x k. But, unlike the averaging method, instead of replacing the central pixel with the average of the neighborhood, we instead replace the central pixel with the median of the neighborhood.)</p><p>平均和高斯方法可以计算邻域的平均值或加权平均值-这个平均像素强度可能存在或不存在于邻域中。但是根据定义，中值像素必须存在于我们的邻域中。通过用中位数而不是平均数来代替我们的中心像素，我们可以大大降低噪声(Averaging and Gaussian methods can compute means or weighted means for the neighborhood – this average pixel intensity may or may not be present in the neighborhood. But by definition, the median pixel must exist in our neighborhood. By replacing our central pixel with a median rather than an average, we can substantially reduce noise.)</p><p>使用  cv2.medianBlur(image,kernel) 方法进行中值模糊<br>内核大小k</p><figure class="highlight python"><figcaption><span>平滑和模糊</span><a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">blurring.py</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">blurred =  np.hstack([cv2.medianBlur(image,<span class="number">3</span>),cv2.medianBlur(image,<span class="number">5</span>),cv2.medianBlur(image,<span class="number">7</span>)])</span><br><span class="line"><span class="comment"># 前面的滤波器都是用计算得到的一个新值来取代中</span></span><br><span class="line"><span class="comment"># 心像素的值，而中值滤波是用中心像素周围（也可以使他本身）的值来取代他。</span></span><br><span class="line"><span class="comment"># 他能有效的去除噪声。卷积核的大小也应该是一个奇数。</span></span><br><span class="line">cv2.imshow(<span class="string">"Median"</span>,blurred)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>  <img src="/images/PracPythonOpenCV10-3.png" width="400" height="400" title="图·3"><h3 id="四、双边滤波-bilateral"><a href="#四、双边滤波-bilateral" class="headerlink" title="四、双边滤波-bilateral"></a>四、双边滤波-bilateral</h3><p>到目前为止，我们的模糊方法的目的是降低图像中的噪声和细节;但是，我们往往会失去图像的边缘。<br>函数cv2.bilateralFilter() 能在保持边界清晰的情况下有效的去除噪音。<br>    但是这种操作与其他滤波器相比会比较慢。我们已经知道高斯滤波器是求中心点邻近区域像素的高斯加权平均值。这种高斯滤波器只考虑像素之间的空间关系，而不会考虑像素值之间的关系（像素的相似度）。所以这种方法不会考虑一个像素是否位于边界。因此边界也会别模糊掉，而这正不是我们想要。双边滤波在同时使用空间高斯权重和灰度值相似性高斯权重。空间高斯函数确保只有邻近区域的像素对中心点有影响，灰度值相似性高斯函数确保只有与中心像素灰度值相近的才会被用来做模糊运算。所以这种方法会确保边界不会被模糊掉，因为边界处的灰度值变化比较大。</p><blockquote><br>#cv2.bilateralFilter(src, d, sigmaColor, sigmaSpace)<br>#d – Diameter of each pixel neighborhood that is used during filtering.我们的像素邻域的直径<br># If it is non-positive, it is computed from sigmaSpace<br>#5 邻域直径，两个21 分别是空间高斯函数标准差，灰度值相似性高斯函数标准差<br><br># 第三个参数是我们的颜色标准差。颜色标准差值越大意味着在计算模糊时将考虑邻域中更多的颜色。<br># 最后，我们需要提供空间标准差。空间标准差值越大意味着离中心像素越远的像素也会影响模糊计算，只要它们的颜色足够相似即可。<br></blockquote><figure class="highlight python"><figcaption><span>平滑和模糊</span><a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">blurring.py</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">blurred =  np.hstack([cv2.bilateralFilter(image,<span class="number">5</span>,<span class="number">21</span>,<span class="number">21</span>),cv2.bilateralFilter(image,<span class="number">7</span>,<span class="number">31</span>,<span class="number">31</span>),cv2.bilateralFilter(image,<span class="number">9</span>,<span class="number">41</span>,<span class="number">41</span>)])</span><br><span class="line"><span class="comment">#cv2.bilateralFilter(src, d, sigmaColor, sigmaSpace)</span></span><br><span class="line"><span class="comment">#d – Diameter of each pixel neighborhood that is used during filtering.</span></span><br><span class="line"><span class="comment"># If it is non-positive, it is computed from sigmaSpace</span></span><br><span class="line"><span class="comment">#5 邻域直径，两个21 分别是空间高斯函数标准差，灰度值相似性高斯函数标准差</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三个参数是我们的颜色标准差。颜色标准差值越大意味着在计算模糊时将考虑邻域中更多的颜色。</span></span><br><span class="line"><span class="comment"># 最后，我们需要提供空间标准差。空间标准差值越大意味着离中心像素越远的像素也会影响模糊计算，只要它们的颜色足够相似即可。</span></span><br><span class="line">cv2.imshow(<span class="string">"Median"</span>,blurred)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>  <img src="/images/PracPythonOpenCV10-4.png" width="400" height="400" title="图·4"><blockquote class="blockquote-center">在机会的世界里，没有太多机会可以争取;如果你真想成功，要设法抢夺别人的机会。</blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;blurring：图像中的每个像素都与其周围的像素强度混合在一起。这个邻域像素的“混合”成为我们模糊的像素。&lt;/p&gt;
&lt;p&gt;事实上，如果图像首先被平滑或模糊，许多图像处理和计算机视觉功能，如阈值和边缘检测，性能会更好。&lt;/p&gt;
&lt;h3 id=&quot;一、平均-averaging&quot;
      
    
    </summary>
    
      <category term="opencv" scheme="https://harveyyeung.github.io/categories/opencv/"/>
    
    
      <category term="opencv" scheme="https://harveyyeung.github.io/tags/opencv/"/>
    
      <category term="python" scheme="https://harveyyeung.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>opencv入门9:直方图-histogram</title>
    <link href="https://harveyyeung.github.io/2018/01/29/PracPythonOpenCV/PracPythonOpenCV9/"/>
    <id>https://harveyyeung.github.io/2018/01/29/PracPythonOpenCV/PracPythonOpenCV9/</id>
    <published>2018-01-29T03:18:07.000Z</published>
    <updated>2018-01-31T03:24:01.157Z</updated>
    
    <content type="html"><![CDATA[<p>什么是直方图呢？通过直方图你可以对整幅图像的灰度分布有一个整体的了解。直方图的x 轴是灰度值（0 到255），y 轴是图片中具有同一个灰度值的点的数目。</p><p>直方图其实就是对图像的另一种解释。一下图为例，通过直方图我们可以对图像的对比度，亮度，灰度分布等有一个直观的认识。几乎所有的图像处理软件都提供了直方图分析功能。下图来自Cambridge in Color website，强烈推荐你到这个网站了解更多知识。<br><img src="/images/PracPythonOpenCV9-1.png" width="400" height="400" title="图·1"></p><p>让我们来一起看看这幅图片和它的直方图吧。（要记住，直方图是根据灰度图像绘制的，而不是彩色图像）。直方图的左边区域像是了暗一点的像素数量，右侧显示了亮一点的像素的数量。从这幅图上你可以看到灰暗的区域比两的区域要大，而处于中间部分的像素点很少。</p><h3 id="一、使用opencv计算直方图"><a href="#一、使用opencv计算直方图" class="headerlink" title="一、使用opencv计算直方图"></a>一、使用opencv计算直方图</h3><blockquote><br> 方法：cv2.calcHist(images,channels,mask,histSize,ranges)<br>1. images: 原图像（图像格式为uint8 或float32）。当传入函数时应该<br>用中括号[] 括起来，例如：[img]。<br>2. channels: 同样需要用中括号括起来，它会告诉函数我们要统计那幅图<br>像的直方图。如果输入图像是灰度图，它的值就是[0]；如果是彩色图像<br>的话，传入的参数可以是[0]，[1]，[2] 它们分别对应着通道B，G，R。<br>3. mask: 掩模图像。要统计整幅图像的直方图就把它设为None。但是如<br>果你想统计图像某一部分的直方图的话，你就需要制作一个掩模图像，并<br>使用它。（后边有例子）<br>4. histSize:BIN 的数目。也应该用中括号括起来，例如：[256]。<br>5. ranges: 像素值范围，通常为[0，256]<br></blockquote><p>BINS：上面的直方图显示了每个灰度值对应的像素数。如果像素值为0到255，你就需要256 个数来显示上面的直方图。但是，如果你不需要知道<br>每一个像素值的像素点数目的，而只希望知道两个像素值之间的像素点数目怎么办呢？举例来说，我们想知道像素值在0 到15 之间的像素点的数目，接着<br>是16 到31,….，240 到255。我们只需要16 个值来绘制直方图。OpenCV Tutorials on histograms中例子所演示的内容。<br>那到底怎么做呢？你只需要把原来的256 个值等分成16 小组，取每组的总和。而这里的每一个小组就被成为BIN。第一个例子中有256 个BIN，第二个例子中有16 个BIN。在OpenCV 的文档中用histSize 表示BINS。</p><p>DIMS：表示我们收集数据的参数数目。在本例中，我们对收集到的数据只考虑一件事：灰度值。所以这里就是1。RANGE：就是要统计的灰度值范围，一般来说为[0，256]，也就是说所有的灰度值</p><figure class="highlight python"><figcaption><span>直方图</span><a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">grayscale_histogram.py</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">ap = argparse.ArgumentParser()</span><br><span class="line">ap.add_argument(<span class="string">"-i"</span>,<span class="string">"--image"</span>,required = <span class="keyword">True</span>,help = <span class="string">"Path to the image"</span>)</span><br><span class="line">args = vars(ap.parse_args())</span><br><span class="line"></span><br><span class="line">image = cv2.imread(args[<span class="string">"image"</span>])</span><br><span class="line"></span><br><span class="line">image = cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)</span><br><span class="line">cv2.imshow(<span class="string">"Original"</span>,image)</span><br><span class="line"></span><br><span class="line">hist = cv2.calcHist([image],[<span class="number">0</span>],<span class="keyword">None</span>,[<span class="number">256</span>],[<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.title(<span class="string">"Grayscale Histogram"</span>)</span><br><span class="line">plt.xlabel(<span class="string">"Bins"</span>)</span><br><span class="line">plt.ylabel(<span class="string">"# of Pixels"</span>)</span><br><span class="line">plt.plot(hist)</span><br><span class="line">plt.xlim([<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line">plt.show()</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>  <img src="/images/PracPythonOpenCV9-2.png" width="400" height="400" title="图·2"><figure class="highlight python"><figcaption><span>直方图</span><a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">color_histograms.py</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">ap = argparse.ArgumentParser()</span><br><span class="line">ap.add_argument(<span class="string">"-i"</span>,<span class="string">"--image"</span>,required = <span class="keyword">True</span>,help = <span class="string">"Path to the image"</span>)</span><br><span class="line">args = vars(ap.parse_args())</span><br><span class="line"></span><br><span class="line">image = cv2.imread(args[<span class="string">"image"</span>])</span><br><span class="line"></span><br><span class="line">chans = cv2.split(image)</span><br><span class="line">colors = (<span class="string">"b"</span>,<span class="string">"g"</span>,<span class="string">"r"</span>)</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.title(<span class="string">"Grayscale Histogram"</span>)</span><br><span class="line">plt.xlabel(<span class="string">"Bins"</span>)</span><br><span class="line">plt.ylabel(<span class="string">"# of Pixels"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (chan,color) <span class="keyword">in</span> zip(chans,colors):</span><br><span class="line">    hist = cv2.calcHist([chan],[<span class="number">0</span>],<span class="keyword">None</span>,[<span class="number">256</span>],[<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line">    plt.plot(hist,color = color)</span><br><span class="line">    plt.xlim([<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line"></span><br><span class="line">plt.show()</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>  <img src="/images/PracPythonOpenCV9-3.png" width="400" height="400" title="图·3"><figure class="highlight python"><figcaption><span>直方图</span><a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">color_histograms2.py</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">ap = argparse.ArgumentParser()</span><br><span class="line">ap.add_argument(<span class="string">"-i"</span>,<span class="string">"--image"</span>,required = <span class="keyword">True</span>,help = <span class="string">"Path to the image"</span>)</span><br><span class="line">args = vars(ap.parse_args())</span><br><span class="line"></span><br><span class="line">image = cv2.imread(args[<span class="string">"image"</span>])</span><br><span class="line"></span><br><span class="line">chans = cv2.split(image)</span><br><span class="line">colors = (<span class="string">"b"</span>,<span class="string">"g"</span>,<span class="string">"r"</span>)</span><br><span class="line"></span><br><span class="line">fig=plt.figure()</span><br><span class="line"></span><br><span class="line">ax = fig.add_subplot(<span class="number">131</span>)</span><br><span class="line">hist= cv2.calcHist([chans[<span class="number">1</span>],chans[<span class="number">0</span>]],[<span class="number">0</span>,<span class="number">1</span>],<span class="keyword">None</span>,[<span class="number">32</span>,<span class="number">32</span>],[<span class="number">0</span>,<span class="number">256</span>,<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line">p = ax.imshow(hist,interpolation = <span class="string">"nearest"</span>)</span><br><span class="line">ax.set_title(<span class="string">"2D color Historgram for G and B"</span>)</span><br><span class="line">plt.colorbar(p)</span><br><span class="line"></span><br><span class="line">ax = fig.add_subplot(<span class="number">132</span>)</span><br><span class="line">hist= cv2.calcHist([chans[<span class="number">1</span>],chans[<span class="number">2</span>]],[<span class="number">0</span>,<span class="number">1</span>],<span class="keyword">None</span>,[<span class="number">32</span>,<span class="number">32</span>],[<span class="number">0</span>,<span class="number">256</span>,<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line">p = ax.imshow(hist,interpolation = <span class="string">"nearest"</span>)</span><br><span class="line">ax.set_title(<span class="string">"2D color Historgram for G and R"</span>)</span><br><span class="line">plt.colorbar(p)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ax = fig.add_subplot(<span class="number">133</span>)</span><br><span class="line">hist= cv2.calcHist([chans[<span class="number">0</span>],chans[<span class="number">2</span>]],[<span class="number">0</span>,<span class="number">1</span>],<span class="keyword">None</span>,[<span class="number">32</span>,<span class="number">32</span>],[<span class="number">0</span>,<span class="number">256</span>,<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line">p = ax.imshow(hist,interpolation = <span class="string">"nearest"</span>)</span><br><span class="line">ax.set_title(<span class="string">"2D color Historgram for B and R"</span>)</span><br><span class="line">plt.colorbar(p)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br><span class="line">print(<span class="string">"2D histogram shape:&#123;&#125;,with &#123;&#125; values"</span>.format(hist.shape,hist.flatten().shape[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure>  <blockquote><br>为了同时在一个窗口中显示多个图像，我们使用函数plt.subplot()。你<br>可以通过查看Matplotlib 的文档获得更多详细信息<br></blockquote><p>蓝色阴影表示低像素计数，而红色阴影表示大像素计数（即，2D图形中的峰值）</p><img src="/images/PracPythonOpenCV9-4.png" width="400" height="400" title="图·4"><h3 id="二、直方图均衡化-histogram-equalization"><a href="#二、直方图均衡化-histogram-equalization" class="headerlink" title="二、直方图均衡化 -histogram equalization"></a>二、直方图均衡化 -histogram equalization</h3><p>直方图均衡通过“拉伸”像素的分布来改善图像的对比度。<br>应用直方图均衡会将峰值拉向图像的角落，从而改善图像的全局对比度。直方图均衡适用于灰度图像</p><img src="/images/PracPythonOpenCV9-5.png" width="400" height="400" title="图·5"><p>执行直方图均衡仅使用单个函数完成：cv2.equalizeHist（image）它接受一个单一的参数，灰度图像，我们要执行直方图均衡。</p><figure class="highlight python"><figcaption><span>直方图</span><a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">histogram_with_mask.py</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">ap = argparse.ArgumentParser()</span><br><span class="line">ap.add_argument(<span class="string">"-i"</span>,<span class="string">"--image"</span>,required = <span class="keyword">True</span>,help = <span class="string">"Path to the image"</span>)</span><br><span class="line">args = vars(ap.parse_args())</span><br><span class="line"></span><br><span class="line">image = cv2.imread(args[<span class="string">"image"</span>])</span><br><span class="line">image = cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line">eq = cv2.equalizeHist(image)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">"Histogram Equalization"</span>,np.vstack([image,eq]))</span><br><span class="line"><span class="comment">#hstack  横向堆叠图像   vstack纵向</span></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>  <h3 id="三、使用掩模"><a href="#三、使用掩模" class="headerlink" title="三、使用掩模"></a>三、使用掩模</h3><figure class="highlight python"><figcaption><span>直方图</span><a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">histogram_with_mask.py</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_histogram</span><span class="params">(image,title,mask=None)</span>:</span></span><br><span class="line">    chans = cv2.split(image)</span><br><span class="line">    colors = (<span class="string">"b"</span>,<span class="string">"g"</span>,<span class="string">"r"</span>)</span><br><span class="line">    plt.figure()</span><br><span class="line">    plt.title(title)</span><br><span class="line">    plt.xlabel(<span class="string">"Bins"</span>)</span><br><span class="line">    plt.ylabel(<span class="string">"# of Pixels"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (chan,color) <span class="keyword">in</span> zip(chans,colors):</span><br><span class="line">        hist = cv2.calcHist([chan],[<span class="number">0</span>],mask,[<span class="number">256</span>],[<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line">        plt.plot(hist,color = color)</span><br><span class="line">        plt.xlim([<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ap = argparse.ArgumentParser()</span><br><span class="line">ap.add_argument(<span class="string">"-i"</span>,<span class="string">"--image"</span>,required =<span class="keyword">True</span>, help=<span class="string">"Path to the image"</span>)</span><br><span class="line">args = vars(ap.parse_args())</span><br><span class="line"></span><br><span class="line">image = cv2.imread(args[<span class="string">"image"</span>])</span><br><span class="line">cv2.imshow(<span class="string">"Original"</span>,image)</span><br><span class="line"></span><br><span class="line">mask = np.zeros(image.shape[:<span class="number">2</span>],dtype =<span class="string">"uint8"</span>)</span><br><span class="line">(cx,cy) = (image.shape[<span class="number">1</span>]//<span class="number">2</span>,image.shape[<span class="number">0</span>]//<span class="number">2</span>)</span><br><span class="line">cv2.rectangle(mask,(cx<span class="number">-250</span>,cy<span class="number">-150</span>),(cx+<span class="number">200</span> ,cy+<span class="number">150</span>),<span class="number">255</span>,<span class="number">-1</span>)</span><br><span class="line">cv2.imshow(<span class="string">"Mask"</span>,mask)</span><br><span class="line"></span><br><span class="line">masked = cv2.bitwise_and(image,image,mask=mask)</span><br><span class="line">cv2.imshow(<span class="string">"Applying the mask"</span>,masked)</span><br><span class="line"></span><br><span class="line">plot_histogram(image,<span class="string">"Histogram for Masked Image"</span>,mask = mask)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>  <img src="/images/PracPythonOpenCV9-6.png" width="400" height="400" title="图·6"><blockquote class="blockquote-center">人生最大的痛苦不是失败，而是没有经历自己想要经历的一切.</blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;什么是直方图呢？通过直方图你可以对整幅图像的灰度分布有一个整体的了解。直方图的x 轴是灰度值（0 到255），y 轴是图片中具有同一个灰度值的点的数目。&lt;/p&gt;
&lt;p&gt;直方图其实就是对图像的另一种解释。一下图为例，通过直方图我们可以对图像的对比度，亮度，灰度分布等有一个直观
      
    
    </summary>
    
      <category term="opencv" scheme="https://harveyyeung.github.io/categories/opencv/"/>
    
    
      <category term="opencv" scheme="https://harveyyeung.github.io/tags/opencv/"/>
    
      <category term="python" scheme="https://harveyyeung.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>opencv入门8:色彩空间-color spaces</title>
    <link href="https://harveyyeung.github.io/2018/01/29/PracPythonOpenCV/PracPythonOpenCV8/"/>
    <id>https://harveyyeung.github.io/2018/01/29/PracPythonOpenCV/PracPythonOpenCV8/</id>
    <published>2018-01-29T03:06:03.000Z</published>
    <updated>2018-01-29T03:36:38.135Z</updated>
    
    <content type="html"><![CDATA[<p>我们只探索了RGB色彩空间;然而，还有很多其他的色彩空间可以利用</p><p>色调 - 饱和度值（HSV：Hue-Saturation-Value）色彩空间与人类如何思考和设想色彩更相似。</p><p>然后是 L <em> a </em> b * 色彩空间.</p><p>为了不陷入细节，我会告诉你如何转换色彩空间。如果您认为您的图像处理和计算机视觉应用可能需要与RGB不同的色彩空间，那么我将作为练习留给读者去探索每个色彩空间的特性。</p><blockquote><br>cv2.cvtColor(image, cv2.COLOR_BGR2HSV)<br><a href="https://docs.opencv.org/3.0-beta/modules/imgproc/doc/miscellaneous_transformations.html?highlight=cvtcolor#cv2.cvtColor" target="_blank" rel="noopener">https://docs.opencv.org/3.0-beta/modules/imgproc/doc/miscellaneous_transformations.html?highlight=cvtcolor#cv2.cvtColor</a><br></blockquote><figure class="highlight python"><figcaption><span>色彩空间</span><a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">colorspaces.py</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">ap = argparse.ArgumentParser()</span><br><span class="line">ap.add_argument(<span class="string">"-i"</span>,<span class="string">"--image"</span>,required = <span class="keyword">True</span>,help = <span class="string">"Path to the image"</span>)</span><br><span class="line">args = vars(ap.parse_args())</span><br><span class="line"></span><br><span class="line">image = cv2.imread(args[<span class="string">"image"</span>])</span><br><span class="line">cv2.imshow(<span class="string">"Original"</span>,image)</span><br><span class="line"></span><br><span class="line">gray = cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)</span><br><span class="line">cv2.imshow(<span class="string">"Gray"</span>,gray)</span><br><span class="line"><span class="comment"># 我们通过指定cv2.COLOR_BGR2GRAY标志将我们的图像从RGB颜色空间转换为灰度</span></span><br><span class="line"></span><br><span class="line">hsv = cv2.cvtColor(image,cv2.COLOR_BGR2HSV)</span><br><span class="line">cv2.imshow(<span class="string">"HSV"</span>,hsv)</span><br><span class="line"></span><br><span class="line">lab = cv2.cvtColor(image,cv2.COLOR_BGR2LAB)</span><br><span class="line">cv2.imshow(<span class="string">"L*a*b*"</span>,lab)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>  <img src="/images/PracPythonOpenCV8-1.png" width="200" height="300" title="图·1"><blockquote class="blockquote-center">简单是可靠的先决条件.</blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们只探索了RGB色彩空间;然而，还有很多其他的色彩空间可以利用&lt;/p&gt;
&lt;p&gt;色调 - 饱和度值（HSV：Hue-Saturation-Value）色彩空间与人类如何思考和设想色彩更相似。&lt;/p&gt;
&lt;p&gt;然后是 L &lt;em&gt; a &lt;/em&gt; b * 色彩空间.&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="opencv" scheme="https://harveyyeung.github.io/categories/opencv/"/>
    
    
      <category term="opencv" scheme="https://harveyyeung.github.io/tags/opencv/"/>
    
      <category term="python" scheme="https://harveyyeung.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>opencv入门7:拆分和合并渠道-splitting and merging channels</title>
    <link href="https://harveyyeung.github.io/2018/01/25/PracPythonOpenCV/PracPythonOpenCV7/"/>
    <id>https://harveyyeung.github.io/2018/01/25/PracPythonOpenCV/PracPythonOpenCV7/</id>
    <published>2018-01-25T02:56:29.000Z</published>
    <updated>2018-01-29T03:39:15.047Z</updated>
    
    <content type="html"><![CDATA[<p>彩色图像由多个通道组成：红色，绿色和蓝色组件<br>拆分图像颜色通道使用cv2.split(image)方法<br>合并 使用  cv2.merge([B,G,R]) 方法<br><figure class="highlight python"><figcaption><span>拆分和合并渠道</span><a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">splitting_and_merging.py</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">ap = argparse.ArgumentParser()</span><br><span class="line">ap.add_argument(<span class="string">"-i"</span>,<span class="string">"--image"</span>,required =<span class="keyword">True</span>, help=<span class="string">"Path to the image"</span>)</span><br><span class="line">args = vars(ap.parse_args())</span><br><span class="line"></span><br><span class="line">image = cv2.imread(args[<span class="string">"image"</span>])</span><br><span class="line">(B,G,R) = cv2.split(image)</span><br><span class="line"><span class="comment"># 我们在RGB色彩空间中考虑图像 - 红色像素第一，绿色像素第二，蓝色像素第三。</span></span><br><span class="line"><span class="comment">#但是，OpenCV以反向通道顺序将RGB图像存储为NumPy数组。而不是以RGB顺序存储图像，而是以BGR顺序存储图像;因此我们按照相反的顺序解开元组</span></span><br><span class="line">cv2.imshow(<span class="string">"Red"</span>,R)</span><br><span class="line">cv2.imshow(<span class="string">"Green"</span>,G)</span><br><span class="line">cv2.imshow(<span class="string">"Blue"</span>,B)</span><br><span class="line"></span><br><span class="line">merged = cv2.merge([B,G,R])</span><br><span class="line">cv2.imshow(<span class="string">"Merged"</span>,merged)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line">zeros = np.zeros(image.shape[:<span class="number">2</span>],dtype=<span class="string">"uint8"</span>)</span><br><span class="line">cv2.imshow(<span class="string">"Red"</span>,cv2.merge([zeros,zeros,R]))</span><br><span class="line">cv2.imshow(<span class="string">"Green"</span>,cv2.merge([zeros,G,zeros]))</span><br><span class="line">cv2.imshow(<span class="string">"Blue"</span>,cv2.merge([B,zeros,zeros]))</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 为了显示频道的实际“颜色”，我们首先需要使用cv2.split来分割图像。</span></span><br><span class="line"><span class="comment"># 然后，我们需要重新构建图像，</span></span><br><span class="line"><span class="comment"># 但这次设置所有像素为0，除了当前通道</span></span><br></pre></td></tr></table></figure><br><img src="/images/PracPythonOpenCV7-1.png" width="200" height="300" title="图·1"><br><img src="/images/PracPythonOpenCV7-2.png" width="200" height="300" title="图·2"></p><blockquote class="blockquote-center">把时间当朋友。</blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;彩色图像由多个通道组成：红色，绿色和蓝色组件&lt;br&gt;拆分图像颜色通道使用cv2.split(image)方法&lt;br&gt;合并 使用  cv2.merge([B,G,R]) 方法&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;figcaption&gt;&lt;s
      
    
    </summary>
    
      <category term="opencv" scheme="https://harveyyeung.github.io/categories/opencv/"/>
    
    
      <category term="opencv" scheme="https://harveyyeung.github.io/tags/opencv/"/>
    
      <category term="python" scheme="https://harveyyeung.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>opencv入门6:蒙版-masking</title>
    <link href="https://harveyyeung.github.io/2018/01/17/PracPythonOpenCV/PracPythonOpenCV6/"/>
    <id>https://harveyyeung.github.io/2018/01/17/PracPythonOpenCV/PracPythonOpenCV6/</id>
    <published>2018-01-17T04:10:16.000Z</published>
    <updated>2018-01-25T03:03:58.212Z</updated>
    
    <content type="html"><![CDATA[<p>使用蒙板可以让我们只关注感兴趣的图像部分。<br>掩码的关键点是它们允许我们将计算的重点仅限于感兴趣的图像区域.<br><img src="/images/PracPythonOpenCV6-1.png" width="200" height="300" title="图·1"><br><img src="/images/PracPythonOpenCV6-2.png" width="200" height="300" title="图·2"></p><blockquote>详细解释：<br><a href="https://docs.opencv.org/3.0-beta/modules/core/doc/operations_on_arrays.html?highlight=bitwise_and#cv2.bitwise_and" target="_blank" rel="noopener">https://docs.opencv.org/3.0-beta/modules/core/doc/operations_on_arrays.html?<br>highlight=bitwise_and#cv2.bitwise_and</a><br></blockquote><br><figure class="highlight python"><figcaption><span>蒙板</span><a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">masking.py</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">ap = argparse.ArgumentParser()</span><br><span class="line">ap.add_argument(<span class="string">"-i"</span>,<span class="string">"--image"</span>,required =<span class="keyword">True</span>, help=<span class="string">"Path to the image"</span>)</span><br><span class="line">args = vars(ap.parse_args())</span><br><span class="line"></span><br><span class="line">image = cv2.imread(args[<span class="string">"image"</span>])</span><br><span class="line">cv2.imshow(<span class="string">"Original"</span>,image)</span><br><span class="line"></span><br><span class="line">mask = np.zeros(image.shape[:<span class="number">2</span>],dtype =<span class="string">"uint8"</span>)</span><br><span class="line">(cx,cy) = (image.shape[<span class="number">1</span>]//<span class="number">2</span>,image.shape[<span class="number">0</span>]//<span class="number">2</span>)</span><br><span class="line">cv2.rectangle(mask,(cx<span class="number">-250</span>,cy<span class="number">-150</span>),(cx+<span class="number">200</span> ,cy+<span class="number">150</span>),<span class="number">255</span>,<span class="number">-1</span>)</span><br><span class="line">cv2.imshow(<span class="string">"Mask"</span>,mask)</span><br><span class="line"></span><br><span class="line">masked = cv2.bitwise_and(image,image,mask=mask)</span><br><span class="line"><span class="comment">#bitwise_and方法前两个参数是图像本身</span></span><br><span class="line">掩码只考虑掩码大于零的原始图像中的像素</span><br><span class="line">cv2.imshow(<span class="string">"Mask applied to image"</span>,masked)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mask = np.zeros(image.shape[:<span class="number">2</span>], dtype = <span class="string">"uint8"</span>)</span><br><span class="line">cv2.circle(mask, (cx, cy), <span class="number">100</span>, <span class="number">255</span>, <span class="number">-1</span>)</span><br><span class="line">masked = cv2.bitwise_and(image, image, mask = mask)</span><br><span class="line">cv2.imshow(<span class="string">"Mask"</span>, mask)</span><br><span class="line">cv2.imshow(<span class="string">"Mask Applied to Image"</span>, masked)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><br><br><br><blockquote class="blockquote-center">现实不似你所见。</blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用蒙板可以让我们只关注感兴趣的图像部分。&lt;br&gt;掩码的关键点是它们允许我们将计算的重点仅限于感兴趣的图像区域.&lt;br&gt;&lt;img src=&quot;/images/PracPythonOpenCV6-1.png&quot; width=&quot;200&quot; height=&quot;300&quot; title=&quot;图·
      
    
    </summary>
    
      <category term="opencv" scheme="https://harveyyeung.github.io/categories/opencv/"/>
    
    
      <category term="opencv" scheme="https://harveyyeung.github.io/tags/opencv/"/>
    
      <category term="python" scheme="https://harveyyeung.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>opencv入门5:按位操作-bitwise operations</title>
    <link href="https://harveyyeung.github.io/2018/01/15/PracPythonOpenCV/PracPythonOpenCV5/"/>
    <id>https://harveyyeung.github.io/2018/01/15/PracPythonOpenCV/PracPythonOpenCV5/</id>
    <published>2018-01-15T02:42:48.000Z</published>
    <updated>2018-01-17T07:02:39.162Z</updated>
    
    <content type="html"><![CDATA[<p>现在我们将回顾四个按位运算：AND，OR，XOR和NOT。这四个操作虽然非常基础和低级，但对于图像处理至关重要，特别是当我们在6节开始使用蒙版时。</p><p>按位操作以二进制方式操作，并以灰度图像表示:</p><figure class="highlight python"><figcaption><span>按位操作</span><a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">bitwise.py</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">rectangle = np.zeros((<span class="number">300</span>,<span class="number">300</span>),dtype=<span class="string">"uint8"</span>)</span><br><span class="line">cv2.rectangle(rectangle,(<span class="number">25</span>,<span class="number">25</span>),(<span class="number">275</span>,<span class="number">275</span>),<span class="number">255</span>,<span class="number">-1</span>)</span><br><span class="line">cv2.imshow(<span class="string">"Rectangle"</span>,rectangle)</span><br><span class="line"></span><br><span class="line">circle = np.zeros((<span class="number">300</span>,<span class="number">300</span>),dtype=<span class="string">"uint8"</span>)</span><br><span class="line">cv2.circle(circle,(<span class="number">150</span>,<span class="number">150</span>),<span class="number">150</span>,<span class="number">255</span>,<span class="number">-1</span>)</span><br><span class="line">cv2.imshow(<span class="string">"Circle"</span>,circle)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">bitwiseAnd = cv2.bitwise_and(rectangle,circle)</span><br><span class="line">cv2.imshow(<span class="string">"And"</span>,bitwiseAnd)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">bitwiseOr = cv2.bitwise_or(rectangle,circle)</span><br><span class="line">cv2.imshow(<span class="string">"OR"</span>,bitwiseOr)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">bitwiseXor = cv2.bitwise_xor(rectangle,circle)</span><br><span class="line">cv2.imshow(<span class="string">"XOR"</span>,bitwiseXor)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">bitwiseNot = cv2.bitwise_not(rectangle)</span><br><span class="line">cv2.imshow(<span class="string">"Not"</span>,bitwiseNot)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>  <blockquote><br># 1. AND: A bitwise AND is true if and only if both pixels<br># are greater than zero.<br># 2. OR: A bitwise OR is true if either of the two pixels<br># are greater than zero.<br># 3. XOR: A bitwise XOR is true if and only if either of the<br># two pixels are greater than zero, but not both.<br># 4. NOT: A bitwise NOT inverts the “on” and “off” pixels<br># in an image.<br></blockquote><br>运行结果如下:<br><img src="/images/PracPythonOpenCV5-1.png" width="200" height="300" title="图·1"><br><img src="/images/PracPythonOpenCV5-2.png" width="200" height="300" title="图·2"><br><img src="/images/PracPythonOpenCV5-3.png" width="200" height="300" title="图·3"><br><img src="/images/PracPythonOpenCV5-4.png" width="200" height="300" title="图·4"><br><img src="/images/PracPythonOpenCV5-5.png" width="200" height="300" title="图·5"><br><br><br><br>如果一个给定的像素的值大于零，那么这个像素会被打开，如果它的值为零，它就会被关闭。按位功能在这些二进制条件下运行。<br>1. AND：当且仅当两个像素都大于零时，按位AND才为真。<br>2. OR：如果两个像素中的任何一个大于零，则按位“或”为真。<br>3. XOR 异或功能：当且仅当两个像素中的任何一个大于零时，按位XOR才为真，但不是两者都是。当且仅当两个像素一个大于0一个小于0时才为真，其他都为false<br>4. NOT 取反：倒置图像中的“开”和“关”像素。<br><br><br><blockquote class="blockquote-center">来是偶然，去是必然，尽其当然，顺其自然。</blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在我们将回顾四个按位运算：AND，OR，XOR和NOT。这四个操作虽然非常基础和低级，但对于图像处理至关重要，特别是当我们在6节开始使用蒙版时。&lt;/p&gt;
&lt;p&gt;按位操作以二进制方式操作，并以灰度图像表示:&lt;/p&gt;
&lt;figure class=&quot;highlight pyth
      
    
    </summary>
    
      <category term="opencv" scheme="https://harveyyeung.github.io/categories/opencv/"/>
    
    
      <category term="opencv" scheme="https://harveyyeung.github.io/tags/opencv/"/>
    
      <category term="python" scheme="https://harveyyeung.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>opencv入门4:图像算术-image arithmetic</title>
    <link href="https://harveyyeung.github.io/2018/01/12/PracPythonOpenCV/PracPythonOpenCV4/"/>
    <id>https://harveyyeung.github.io/2018/01/12/PracPythonOpenCV/PracPythonOpenCV4/</id>
    <published>2018-01-12T03:39:06.000Z</published>
    <updated>2018-01-17T07:02:36.741Z</updated>
    
    <content type="html"><![CDATA[<p>RGB的像素值都在[0,255],如果我们想给一个250的像素再加十个像素会怎么样？</p><p>NumPy将执行模算术和“环绕”。比如250 再加10像素，会绕回到4，<br>OpenCV 将执行剪切并确保像素值永远不会超出范围[0,255]</p><blockquote><br>NumPy will perform modulo arithmetic and “wrap around”.<br>OpenCV, on the other hand, will perform clipping and ensure pixel values never fall outside the range [0, 255].<br></blockquote><figure class="highlight python"><figcaption><span>像素算术</span><a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">arithmetic.py</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">ap = argparse.ArgumentParser()</span><br><span class="line">ap.add_argument(<span class="string">"-i"</span>,<span class="string">"--image"</span>,required =<span class="keyword">True</span>, help=<span class="string">"Path to the image"</span>)</span><br><span class="line">args = vars(ap.parse_args())</span><br><span class="line"></span><br><span class="line">image = cv2.imread(args[<span class="string">"image"</span>])</span><br><span class="line">cv2.imshow(<span class="string">"Original"</span>,image)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"max of 255:&#123;&#125;"</span>.format(cv2.add(np.uint8([<span class="number">200</span>]),np.uint8([<span class="number">100</span>]))))</span><br><span class="line">print(<span class="string">"min of 0:&#123;&#125;"</span>.format(cv2.subtract(np.uint8([<span class="number">50</span>]),np.uint8([<span class="number">100</span>]))))</span><br><span class="line"></span><br><span class="line">print(<span class="string">"wrap around :&#123;&#125;"</span>.format(np.uint8([<span class="number">200</span>])+np.uint8([<span class="number">100</span>])))</span><br><span class="line">print(<span class="string">"wrap around :&#123;&#125;"</span>.format(np.uint8([<span class="number">50</span>])-np.uint8([<span class="number">100</span>])))</span><br></pre></td></tr></table></figure>  <p>运行结果如下:<br><img src="/images/PracPythonOpenCV4-1.png" width="200" height="300" title="图·1"></p><figure class="highlight python"><figcaption><span>像素算术</span><a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">arithmetic.py</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">M =np.ones(image.shape, dtype=<span class="string">"uint8"</span>)*<span class="number">100</span></span><br><span class="line"><span class="comment"># defines a NumPy array of ones, with the same</span></span><br><span class="line"><span class="comment"># size as our image.</span></span><br><span class="line"><span class="comment">#为了用100的值而不是1来填充我们的矩阵，我们简单地把1的矩阵乘以100。</span></span><br><span class="line">added = cv2.add(image,M)</span><br><span class="line">cv2.imshow(<span class="string">"Added"</span>,added)</span><br><span class="line"></span><br><span class="line">M = np.ones(image.shape,dtype =<span class="string">"uint8"</span>)*<span class="number">50</span></span><br><span class="line">subtracted = cv2.subtract(image,M)</span><br><span class="line">cv2.imshow(<span class="string">"Subtraced"</span>,subtracted)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>  <img src="/images/PracPythonOpenCV4-2.png" width="200" height="300" title="图·2"><blockquote class="blockquote-center">一件事情的毕业，永远是另一件事情的开启.</blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;RGB的像素值都在[0,255],如果我们想给一个250的像素再加十个像素会怎么样？&lt;/p&gt;
&lt;p&gt;NumPy将执行模算术和“环绕”。比如250 再加10像素，会绕回到4，&lt;br&gt;OpenCV 将执行剪切并确保像素值永远不会超出范围[0,255]&lt;/p&gt;
&lt;blockquo
      
    
    </summary>
    
      <category term="opencv" scheme="https://harveyyeung.github.io/categories/opencv/"/>
    
    
      <category term="opencv" scheme="https://harveyyeung.github.io/tags/opencv/"/>
    
      <category term="python" scheme="https://harveyyeung.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>opencv入门3:图片操作-image transformations</title>
    <link href="https://harveyyeung.github.io/2018/01/09/PracPythonOpenCV/PracPythonOpenCV3/"/>
    <id>https://harveyyeung.github.io/2018/01/09/PracPythonOpenCV/PracPythonOpenCV3/</id>
    <published>2018-01-09T09:32:08.000Z</published>
    <updated>2018-01-17T07:02:34.241Z</updated>
    
    <content type="html"><![CDATA[<blockquote>如opencv开发前的准备工作中所说,此系列文章是在学习<a href="https://jackmk.ctfile.com/fs/14155983-233384097" target="_blank" rel="noopener">Practical Python and OpenCV</a>(<a href="https://jackmk.ctfile.com/fs/14155983-233384097" target="_blank" rel="noopener">点击下载</a>)这本书的一些记录,发出来的文章跳过了第三章对RGB,以及numpy简单操作等介绍，请大家下载原书查看，在原书中对一下段落已进行翻译注释。文章系列完整展示代码<a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">点击下载</a></blockquote><h3 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h3><figure class="highlight python"><figcaption><span>平移</span><a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">translation.py</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> imutils</span><br><span class="line">ap = argparse.ArgumentParser()</span><br><span class="line">ap.add_argument(<span class="string">"-i"</span>, <span class="string">"--image"</span>, required = <span class="keyword">True</span>, </span><br><span class="line">    help =<span class="string">"Path to the image"</span>)</span><br><span class="line">args = vars(ap.parse_args())</span><br><span class="line"></span><br><span class="line">image = cv2.imread(args[<span class="string">"image"</span>])</span><br><span class="line">cv2.imshow(<span class="string">"Original"</span>, image)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">M = np.float32([[<span class="number">1</span>,<span class="number">0</span>,<span class="number">25</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">50</span>]])</span><br><span class="line"><span class="comment">#定义我们的平移矩阵M</span></span><br><span class="line"><span class="comment">#矩阵M被定义为一个浮点数组 - 这很重要，因为OpenCV期望这个矩阵是浮点类型的。</span></span><br><span class="line"><span class="comment">#矩阵的第一行是[1,0，tx]，其中tx是像素的数量，我们将左右移动图像。</span></span><br><span class="line"><span class="comment">#tx的负值会将图像左移，正值会将图像向右移</span></span><br><span class="line"><span class="comment">#我们将矩阵的第二行定义为[0，1，ty]，其中ty是我们将向上或向下移动图像的像素数量。</span></span><br><span class="line"><span class="comment">#ty的负值会使图像向上移动，正值会使图像向下移动。</span></span><br><span class="line">shifted =cv2.warpAffine(image ,M ,(image.shape[<span class="number">1</span>], image.shape[<span class="number">0</span>]))</span><br><span class="line"><span class="comment">#warpAffine第一个参数是我们想要移动的图像，第二个参数是我们的平移矩阵M.最后，我们手动提供图像的尺寸（宽度和高度）作为第三个参数</span></span><br><span class="line">cv2.imshow(<span class="string">"Shifted Up and Left"</span>,shifted)</span><br><span class="line"></span><br><span class="line">M = np.float32([[<span class="number">1</span>,<span class="number">0</span>,<span class="number">-50</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">-90</span>]])</span><br><span class="line">shifted =cv2.warpAffine(image ,M ,(image.shape[<span class="number">1</span>], image.shape[<span class="number">0</span>]))</span><br><span class="line">cv2.imshow(<span class="string">"Shifted Up and Left"</span>,shifted)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>  <p>以上多次使用warpAffine重复性很高而且 使用起来不方便，我们可以定义一个叫imutils.py的模块封装这个方法如下：</p><figure class="highlight python"><figcaption><span>工具类</span><a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">imutils.py</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">translate</span><span class="params">(image, x, y)</span>:</span></span><br><span class="line">    M = np.float32([[<span class="number">1</span>, <span class="number">0</span>, x], [<span class="number">0</span>, <span class="number">1</span>, y]])</span><br><span class="line">    shifted = cv2.warpAffine(image, M, (image.shape[<span class="number">1</span>], image.shape[<span class="number">0</span>]))</span><br><span class="line">    <span class="keyword">return</span> shifted</span><br></pre></td></tr></table></figure> <p>再实现上面平移的动作:</p><figure class="highlight python"><figcaption><span>平移</span><a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">translation.py</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> imutils</span><br><span class="line"><span class="comment">#使用imutils中“convenience”方法来完成平移，旋转和调整大小等常见任务。</span></span><br><span class="line">ap = argparse.ArgumentParser()</span><br><span class="line">ap.add_argument(<span class="string">"-i"</span>, <span class="string">"--image"</span>, required = <span class="keyword">True</span>, </span><br><span class="line">    help =<span class="string">"Path to the image"</span>)</span><br><span class="line">args = vars(ap.parse_args())</span><br><span class="line"></span><br><span class="line">image = cv2.imread(args[<span class="string">"image"</span>])</span><br><span class="line">cv2.imshow(<span class="string">"Original"</span>, image)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">shifted =imutils.translate(image,<span class="number">0</span>,<span class="number">100</span>)</span><br><span class="line">cv2.imshow(<span class="string">"Shifted Up and Left"</span>,shifted)</span><br><span class="line"></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure> <h3 id="Rotation-旋转一个角度q的图像。"><a href="#Rotation-旋转一个角度q的图像。" class="headerlink" title="Rotation 旋转一个角度q的图像。"></a>Rotation 旋转一个角度q的图像。</h3><figure class="highlight python"><figcaption><span>旋转</span><a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">rotate.py</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> imutils</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">ap = argparse.ArgumentParser()</span><br><span class="line">ap.add_argument(<span class="string">"-i"</span>,<span class="string">"--image"</span>,required =<span class="keyword">True</span>,help =<span class="string">"Path to the image"</span>)</span><br><span class="line">args =vars(ap.parse_args())</span><br><span class="line"></span><br><span class="line">image = cv2.imread(args[<span class="string">"image"</span>])</span><br><span class="line">cv2.imshow(<span class="string">"Original"</span>,image)</span><br><span class="line"></span><br><span class="line">(h,w) = image.shape[:<span class="number">2</span>]</span><br><span class="line">center = (w//<span class="number">2</span>,h//<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">M = cv2.getRotationMatrix2D(center, <span class="number">45</span> , <span class="number">1.0</span>)</span><br><span class="line"><span class="comment">#cv2.getRotationMatrix2D(center, degrees , scale)</span></span><br><span class="line"><span class="comment">#center为需要围绕旋转的点，当我们旋转图像时，我们需要指定我们要旋转的点。</span></span><br><span class="line"><span class="comment">#在大多数情况下，你会想要围绕图像的中心旋转;然而，</span></span><br><span class="line"><span class="comment">#OpenCV允许你指定你想旋转的任意点</span></span><br><span class="line"><span class="comment"># degrees 旋转的角度</span></span><br><span class="line"><span class="comment"># scale 比例 这里你可以指定一个浮点值，其中1.0意味着使用相同的图像转换。但是，如果您指定的值为2.0，则图像的大小将加倍。类似地，0.5的值将图像的大小减半。</span></span><br><span class="line"><span class="comment">#就像我们定义矩阵来翻译图像一样，我们也定义了一个矩阵来旋转图像。我们只需要调用cv2.getRotationMatrix2D方法，而不是使用NumPy手工构造矩阵</span></span><br><span class="line">rotated = cv2.warpAffine(image, M,(w,h))</span><br><span class="line">cv2.imshow(<span class="string">"Rotated by 45 Degrees"</span>, rotated)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">M = cv2.getRotationMatrix2D(center, <span class="number">-90</span>,<span class="number">1.0</span>)</span><br><span class="line">rotated = cv2.warpAffine(image, M ,(w,h))</span><br><span class="line">cv2.imshow(<span class="string">"Rotated by -90 Degrees"</span>,rotated)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rotated = imutils.rotate(image,<span class="number">60</span>,<span class="keyword">None</span>,<span class="number">0.5</span>)</span><br><span class="line">cv2.imshow(<span class="string">"Rotated by imutils"</span>,rotated)</span><br><span class="line"></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure> <p>封装rotate方法<br><figure class="highlight python"><figcaption><span>工具类</span><a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">imutils.py</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(image, angle ,center= None,scale = <span class="number">1.0</span>)</span>:</span></span><br><span class="line">    (h,w)= image.shape[:<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">if</span> center <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        center =(w /<span class="number">2</span>,h/<span class="number">2</span>)</span><br><span class="line">    M = cv2.getRotationMatrix2D(center,angle,scale)</span><br><span class="line">    rotated = cv2.warpAffine(image, M ,(w,h))</span><br><span class="line">    <span class="keyword">return</span> rotated</span><br></pre></td></tr></table></figure><br>调用方式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rotated = imutils.rotate(image,60,None,0.5)</span><br></pre></td></tr></table></figure><h3 id="resize-调整大小"><a href="#resize-调整大小" class="headerlink" title="resize 调整大小"></a>resize 调整大小</h3><figure class="highlight python"><figcaption><span>调整大小</span><a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">resize.py</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> imutils</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">ap = argparse.ArgumentParser()</span><br><span class="line">ap.add_argument(<span class="string">"-i"</span>,<span class="string">"--image"</span>,required = <span class="keyword">True</span>,help = <span class="string">"Path to the image"</span>)</span><br><span class="line"></span><br><span class="line">args = vars(ap.parse_args())</span><br><span class="line"></span><br><span class="line">image = cv2.imread(args[<span class="string">"image"</span>])</span><br><span class="line">cv2.imshow(<span class="string">"Original"</span>,image)</span><br><span class="line"></span><br><span class="line">r = <span class="number">150.0</span> /image.shape[<span class="number">1</span>]</span><br><span class="line"><span class="comment">#定义新图片的宽度为150，为了计算新图片的高度，计算出新图片宽度和当前图片宽度的比例。</span></span><br><span class="line">dim = (<span class="number">150</span>,int(image.shape[<span class="number">0</span>]*r))</span><br><span class="line"><span class="comment">#新图片的宽高</span></span><br><span class="line">resized = cv2.resize(image , dim, interpolation = cv2.INTER_AREA)</span><br><span class="line"></span><br><span class="line"><span class="comment">#cv2.resize(image,dim,interpolation)  </span></span><br><span class="line"><span class="comment">#image 需要调整的图片    dim 新图片的尺寸 </span></span><br><span class="line"><span class="comment">#最后一个参数是我们的插值方法，它是在幕后处理实际图像大小调整的算法</span></span><br><span class="line"><span class="comment">#cv2.INTER_AREA，cv2.INTER_LINEAR,cv2.INTER_CUBIC,cv2.INTER_NEAREST</span></span><br><span class="line"><span class="comment"># interpolation 可选参数</span></span><br><span class="line"><span class="comment"># INTER_NEAREST - a nearest-neighbor interpolation</span></span><br><span class="line"><span class="comment"># INTER_LINEAR - a bilinear interpolation (used by default)</span></span><br><span class="line"><span class="comment"># INTER_AREA - resampling using pixel area relation. It may be a preferred method for image decimation, as it gives moire’-free results. But when the image is zoomed, it is similar to the INTER_NEAREST method.</span></span><br><span class="line"><span class="comment"># INTER_CUBIC - a bicubic interpolation over 4x4 pixel neighborhood</span></span><br><span class="line"><span class="comment"># INTER_LANCZOS4 - a Lanczos interpolation over 8x8 pixel neighborhood</span></span><br><span class="line">NTER_NEAREST - 最近邻居插值</span><br><span class="line">INTER_LINEAR - 双线性插值（默认使用）</span><br><span class="line">INTER_AREA - 使用像素区域关系重采样。这可能是图像抽取的首选方法，因为它可以产生无莫尔效应的结果。但是当图像放大时，它与INTER_NEAREST方法类似。 </span><br><span class="line">INTER_CUBIC - <span class="number">4</span>x4像素邻域上的双三次插值</span><br><span class="line">INTER_LANCZOS4 - <span class="number">8</span>x8像素邻域上的Lanczos插值</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">"resized(width)"</span>,resized)</span><br><span class="line"></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure> <h3 id="Flipping-旋转"><a href="#Flipping-旋转" class="headerlink" title="Flipping 旋转"></a>Flipping 旋转</h3><p>我们可以在x或y轴周围翻转图像，甚至可以翻转图像（We can flip an image around either the x or y axis, or even both.）<br><figure class="highlight python"><figcaption><span>旋转</span><a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">flipping.py</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">ap = argparse.ArgumentParser()</span><br><span class="line">ap.add_argument(<span class="string">"-i"</span>,<span class="string">"--image"</span>,required = <span class="keyword">True</span>,help =<span class="string">"Path to the image"</span>)</span><br><span class="line">args = vars(ap.parse_args())</span><br><span class="line"></span><br><span class="line">image = cv2.imread(args[<span class="string">"image"</span>])</span><br><span class="line">cv2.imshow(<span class="string">"Original"</span>,image)</span><br><span class="line"></span><br><span class="line">flipped = cv2.flip(image,<span class="number">1</span>)</span><br><span class="line">cv2.imshow(<span class="string">"Flipped Horizontally"</span>,flipped)</span><br><span class="line"><span class="comment">#使用1的翻转代码值表示我们将水平地围绕y轴翻转图像。</span></span><br><span class="line"></span><br><span class="line">flipped = cv2.flip(image,<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 指定一个0的翻转代码表示我们想要垂直翻转图像，围绕X轴</span></span><br><span class="line">cv2.imshow(<span class="string">"Flipped Vertically"</span>,flipped)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flipped = cv2.flip(image,<span class="number">-1</span>)</span><br><span class="line"><span class="comment"># 使用负向翻转代码将图像翻转两个轴。</span></span><br><span class="line">cv2.imshow(<span class="string">"Flipped Horizontally&amp;Vertically"</span>,flipped)</span><br><span class="line"></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure> </p><h3 id="Cropping-裁剪"><a href="#Cropping-裁剪" class="headerlink" title="Cropping 裁剪"></a>Cropping 裁剪</h3><p>图片的裁剪使用NumPy数组切片来完成图像裁剪<br><figure class="highlight python"><figcaption><span>裁剪</span><a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">cropping.py</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">ap = argparse.ArgumentParser()</span><br><span class="line">ap.add_argument(<span class="string">"-i"</span>,<span class="string">"--image"</span>,required =<span class="keyword">True</span>, help=<span class="string">"Path to the image"</span>)</span><br><span class="line">args = vars(ap.parse_args())</span><br><span class="line"></span><br><span class="line">image = cv2.imread(args[<span class="string">"image"</span>])</span><br><span class="line">cv2.imshow(<span class="string">"Original"</span>,image)</span><br><span class="line"><span class="comment">#NumPy数组中高度在前面，宽度在后面</span></span><br><span class="line">cropped = image[<span class="number">30</span>:<span class="number">220</span> ,<span class="number">10</span>:<span class="number">335</span>]</span><br><span class="line"><span class="comment">#所以我们需要截取的区域值定义需要按照numpy的格式，如上[starty:endy,startx:endx]</span></span><br><span class="line"><span class="comment"># 1.Start y: The starting y coordinate. In this case, we</span></span><br><span class="line"><span class="comment"># start at y = 30.</span></span><br><span class="line"><span class="comment"># 2. End y: The ending y coordinate. We will end our crop</span></span><br><span class="line"><span class="comment"># at y = 220.</span></span><br><span class="line"><span class="comment"># 3. Start x: The starting x coordinate of the slice. We start</span></span><br><span class="line"><span class="comment"># the crop at x = 10.</span></span><br><span class="line"><span class="comment"># 4. End x: The ending x-axis coordinate of the slice. Our</span></span><br><span class="line"><span class="comment"># slice ends at x = 335.</span></span><br><span class="line">cv2.imshow(<span class="string">"update"</span>,cropped)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure> </p><blockquote class="blockquote-center">凡事往简单处想，往认真处行。</blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;如opencv开发前的准备工作中所说,此系列文章是在学习&lt;a href=&quot;https://jackmk.ctfile.com/fs/14155983-233384097&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Practical P
      
    
    </summary>
    
      <category term="opencv" scheme="https://harveyyeung.github.io/categories/opencv/"/>
    
    
      <category term="opencv" scheme="https://harveyyeung.github.io/tags/opencv/"/>
    
      <category term="python" scheme="https://harveyyeung.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>opencv入门2:使用opencv简单画图</title>
    <link href="https://harveyyeung.github.io/2018/01/05/PracPythonOpenCV/PracPythonOpenCV2/"/>
    <id>https://harveyyeung.github.io/2018/01/05/PracPythonOpenCV/PracPythonOpenCV2/</id>
    <published>2018-01-05T07:23:38.000Z</published>
    <updated>2018-01-17T07:02:31.426Z</updated>
    
    <content type="html"><![CDATA[<blockquote>如opencv开发前的准备工作中所说,此系列文章是在学习<a href="https://jackmk.ctfile.com/fs/14155983-233384097" target="_blank" rel="noopener">Practical Python and OpenCV</a>(<a href="https://jackmk.ctfile.com/fs/14155983-233384097" target="_blank" rel="noopener">点击下载</a>)这本书的一些记录,发出来的文章跳过了第三章对RGB,以及numpy简单操作等介绍，请大家下载原书查看，在原书中对一下段落已进行翻译注释。文章系列完整展示代码<a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">点击下载</a></blockquote><h3 id="线和矩形"><a href="#线和矩形" class="headerlink" title="线和矩形"></a>线和矩形</h3><figure class="highlight python"><figcaption><span>画线</span><a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">drawing.py</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">canvas = np.zeros((<span class="number">300</span>, <span class="number">300</span>, <span class="number">3</span>), dtype = <span class="string">"uint8"</span>)</span><br><span class="line"><span class="comment">#使用np.zeros方法构造一个300，300，3通道的RGB的numpy array</span></span><br><span class="line"><span class="comment">#zeros方法用初始值为零填充数组中的每个元素。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#dtype 数据类型  8进制（</span></span><br><span class="line"><span class="comment">#Since we are representing our image as an RGB image with pixels in the range [0, 255], </span></span><br><span class="line"><span class="comment">#it’s important that we use an 8-bit unsigned integer, or uint8. There #are many </span></span><br><span class="line"><span class="comment">#other data types that we can use (common ones include 32-bit integers, and 32-bit </span></span><br><span class="line"><span class="comment">#or 64-bit floats), but we’ll mainly be using uint8 for the majority of the examples in this book）</span></span><br><span class="line"></span><br><span class="line">green = (<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>)   <span class="comment">#定义一个表示绿色的BGR元组</span></span><br><span class="line">cv2.line(canvas,(<span class="number">0</span>,<span class="number">0</span>),(<span class="number">300</span>,<span class="number">300</span>),green) </span><br><span class="line"><span class="comment">#line(canvas.point1,point2,color) 画布，起点，终点，颜色</span></span><br><span class="line"> </span><br><span class="line">cv2.imshow(<span class="string">"Canvas"</span>, canvas)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">red = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>)</span><br><span class="line">cv2.line(canvas,(<span class="number">300</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">300</span>),red,<span class="number">3</span>)</span><br><span class="line"><span class="comment">#line(canvas.point1,point2,color，thickness) 画布，起点，终点，颜色，线条宽度pixels</span></span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">"Canvas"</span>,canvas)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>  <p>运行结果如下:<br><img src="/images/PracPythonOpenCV2-1.png" width="200" height="300" title="图·1"></p><figure class="highlight python"><figcaption><span>画矩形</span><a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">drawing.py</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cv2.rectangle(canvas,(<span class="number">10</span>,<span class="number">10</span>),(<span class="number">60</span>,<span class="number">60</span>),green)</span><br><span class="line"><span class="comment">#rectangle(canvas,point1,point2,color)画布，起点，终点，颜色</span></span><br><span class="line">we are starting our rectangle at point (<span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line">We decide to end our rectangle at(<span class="number">60</span>, <span class="number">60</span>), </span><br><span class="line">defining a region of <span class="number">50</span> x <span class="number">50</span> pixels</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">"Canvas"</span>,canvas)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">cv2.rectangle(canvas,(<span class="number">50</span>,<span class="number">200</span>),(<span class="number">200</span>,<span class="number">225</span>),red,<span class="number">5</span>)</span><br><span class="line"><span class="comment">#rectangle(canvas,point1,point2,color,thickness) 画布，起点，终点，颜色，线条宽度pixels</span></span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">"Canvas"</span>,canvas)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>  <p>以上我们只绘制了一个矩形的轮廓，如何绘制一个填充满的矩形？<br>&emsp;&emsp;我们只需要通过设置厚度参数为：-1，如下<br><figure class="highlight python"><figcaption><span>填充矩形</span><a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">drawing.py</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">blue = (<span class="number">255</span>, <span class="number">0</span> , <span class="number">0</span>)</span><br><span class="line">cv2.rectangle(canvas,(<span class="number">200</span>,<span class="number">50</span>),(<span class="number">255</span>,<span class="number">125</span>),blue,<span class="number">-1</span>)</span><br><span class="line">cv2.imshow(<span class="string">"Canvas"</span>,canvas)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><br>运行结果如下:<br><img src="/images/PracPythonOpenCV2-2.png" width="200" height="300" title="图·2"></p><h3 id="圆"><a href="#圆" class="headerlink" title="圆"></a>圆</h3><figure class="highlight python"><figcaption><span>画圆</span><a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">drawing.py</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">canvas = np.zeros((<span class="number">300</span>,<span class="number">300</span>,<span class="number">3</span>),dtype = <span class="string">"uint8"</span>)</span><br><span class="line">(centerX,centerY) = (canvas.shape[<span class="number">1</span>] // <span class="number">2</span> ,canvas.shape[<span class="number">0</span>] //<span class="number">2</span>)</span><br><span class="line"><span class="comment">#图像canvas的高度可以在canvas.shape [0]和canvas.shape [1]的宽度中找到。shape [2]为图像channels</span></span><br><span class="line">white = (<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> r <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">175</span>,<span class="number">25</span>):</span><br><span class="line"><span class="comment"># range(start, stop[, step])</span></span><br><span class="line"><span class="comment"># 参数说明：</span></span><br><span class="line"><span class="comment"># start: 计数从 start 开始。默认是从 0 开始。例如range（5）等价于range（0， 5）;</span></span><br><span class="line"><span class="comment"># end: 计数到 end 结束，但不包括 end。例如：range（0， 5） 是[0, 1, 2, 3, 4]没有5</span></span><br><span class="line"><span class="comment"># step：步长，默认为1。例如：range（0， 5） 等价于 range(0, 5, 1)</span></span><br><span class="line">     cv2.circle(canvas,(centerX,centerY),r,white)</span><br><span class="line"><span class="comment"># cv2.circle(canvas,(centerX,centerY),radius,color,thickness) 画布，起点，终点，颜色，线条宽度(为-1时填充整个图像)</span></span><br></pre></td></tr></table></figure> <p>运行结果如下:<br><img src="/images/PracPythonOpenCV2-3.png" width="200" height="300" title="图·3"></p><p>画一个半径，中心点随机的填充多圆图<br><figure class="highlight python"><figcaption><span>画圆</span><a href="https://jackmk.ctfile.com/fs/14155983-233412040" target="_blank" rel="noopener">drawing.py</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">25</span>):</span><br><span class="line">    radius = np.random.randint(<span class="number">5</span>, high =<span class="number">200</span>)</span><br><span class="line"> 使用np.random.randint 生成一个<span class="number">5</span>到<span class="number">200</span>之间的随机数</span><br><span class="line">    color = np.random.randint(<span class="number">0</span>, high =<span class="number">256</span>,size=(<span class="number">3</span>,)).tolist()</span><br><span class="line">    pt = np.random.randint(<span class="number">0</span>, high=<span class="number">300</span>, size = (<span class="number">2</span>,))</span><br><span class="line">    cv2.circle(canvas,tuple(pt),radius,color,<span class="number">-1</span>)</span><br><span class="line">cv2.imshow(<span class="string">"Canvas"</span>,canvas)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><br>运行结果如下:<br><img src="/images/PracPythonOpenCV2-4.png" width="200" height="300" title="图·4"></p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.random.randint(low, high=None, size=None, dtype=<span class="string">'l'</span>)</span><br></pre></td></tr></table></figure><div class="note "><p>Return random integers from low (inclusive) to high (exclusive).<br>Return random integers from the “discrete uniform” distribution of the specified dtype in the “half-open” interval [low, high). If high is None (the default), then results are from [0, low).</p></div><p>Parameters:</p><ul><li>low : intLowest (signed) integer to be drawn from the distribution (unless high=None, in which case this parameter is one above the highest such integer).</li><li>high : int, optionalIf provided, one above the largest (signed) integer to be drawn from the distribution (see above for behavior if high=None).</li><li>size : int or tuple of ints, optionalOutput shape. If the given shape is, e.g., (m, n, k), then m <em> n </em> k samples are drawn. Default is None, in which case a single value is returned.</li><li>dtype : dtype, optionalDesired dtype of the result. All dtypes are determined by their name, i.e., ‘int64’, ‘int’, etc, so byteorder is not available and a specific precision may have different C types depending on the platform. The default value is ‘np.int’.New in version 1.11.0.</li></ul><p>Returns: </p><ul><li>out : int or ndarray of intssize-shaped array of random integers from the appropriate distribution, or a single such random int if size not provided.</li></ul><blockquote class="blockquote-center" "荀子·修身"="">道虽迩，不行不至；事虽小，不为不成</blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;如opencv开发前的准备工作中所说,此系列文章是在学习&lt;a href=&quot;https://jackmk.ctfile.com/fs/14155983-233384097&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Practical P
      
    
    </summary>
    
      <category term="opencv" scheme="https://harveyyeung.github.io/categories/opencv/"/>
    
    
      <category term="opencv" scheme="https://harveyyeung.github.io/tags/opencv/"/>
    
      <category term="python" scheme="https://harveyyeung.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>opencv入门1:opencv开发前的准备工作</title>
    <link href="https://harveyyeung.github.io/2018/01/05/PracPythonOpenCV/PracPythonOpenCV1/"/>
    <id>https://harveyyeung.github.io/2018/01/05/PracPythonOpenCV/PracPythonOpenCV1/</id>
    <published>2018-01-05T05:36:34.000Z</published>
    <updated>2018-01-17T07:02:27.645Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/practicalpythonopencv.png" width="200" height="300"><p>这是我在学习<a href="https://jackmk.ctfile.com/fs/14155983-233384097" target="_blank" rel="noopener">Practical Python and OpenCV</a>(<a href="https://jackmk.ctfile.com/fs/14155983-233384097" target="_blank" rel="noopener">点击下载</a>)这本书的一些记录。计算机视觉的目标是理解图片中展示的内容。为了探索计算机视觉的世界，我们首先需要安装一些软件包和库。作为计算机视觉的初学者，安装其中一些软件包（特别是OpenCV）可能非常繁琐，具体取决于您使用的操作系统。如果遇到问题，请务必查阅软件包的网站以获取最新的安装说明。强烈建议您使用pip来管理软件包的安装。</p><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><p>&emsp;&emsp;在搭建环境的开始，首先确保你已经安装了python.如何安装请看： <a href="http://www.runoob.com/python/python-install.html" target="_blank" rel="noopener">http://www.runoob.com/python/python-install.html</a></p><h3 id="opencv"><a href="#opencv" class="headerlink" title="opencv"></a><a href="http://opencv.org/" target="_blank" rel="noopener">opencv</a></h3><p>&emsp;&emsp;如果NumPy的主要目标是大型高效的多维数组表示，那么OpenCV的主要目标就是实时图像处理,书中作者收集了PyImageSearch上各种Python版本和操作系统的OpenCV安装教程,<a href="https://www.pyimagesearch.com/opencv-tutorials-resources-guides/" target="_blank" rel="noopener">教程地址</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install opencv-python <span class="comment">#安装Opencv-python 的命令</span></span><br></pre></td></tr></table></figure><h3 id="numpy-和-scipy"><a href="#numpy-和-scipy" class="headerlink" title="numpy 和 scipy"></a><a href="http://www.numpy.org/" target="_blank" rel="noopener">numpy</a> 和 <a href="https://www.scipy.org/" target="_blank" rel="noopener">scipy</a></h3><p>&emsp;&emsp;<a href="http://www.numpy.org/" target="_blank" rel="noopener">numpy</a>是Python编程语言的一个库，为大型多维数组提供支持。使用numpy可以将图片转换为多维数组。将图像表示为NumPy数组在计算上和资源效率上表现优异，许多其他图像处理和机器学习库也使用NumPy数组表示。通过使用NumPy内置的高级数学函数，我们可以快速，方便地对图像进行数值分析。</p><p>&emsp;&emsp;<a href="https://www.scipy.org/" target="_blank" rel="noopener">scipy</a>是一个高级的科学计算库，它和Numpy联系很密切，Scipy一般都是操控Numpy数组来进行科学计算，所以可以说是基于Numpy之上了。Scipy有很多子模块可以应对不同的应用，例如插值运算，优化算法、图像处理、数学统计等。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pip install numpy <span class="comment">#安装numpy</span></span><br><span class="line">$ pip install scipy <span class="comment">#安装scipy</span></span><br></pre></td></tr></table></figure></p><h3 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a><a href="http://matplotlib.org/" target="_blank" rel="noopener">matplotlib</a></h3><p>&emsp;&emsp;<a href="http://matplotlib.org/" target="_blank" rel="noopener">matplotlib</a> 是一个绘图库。如果你以前曾经使用过MATLAB，那么在matplotlib环境中你可能会觉得很顺手。分析图像时，我们将使用matplotlib。无论是绘制图像直方图还是简单地查看图像本身，matplotlib都是您工具箱中的绝佳工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install matplotlib <span class="comment">#安装matplotlib</span></span><br></pre></td></tr></table></figure><h3 id="mahotas"><a href="#mahotas" class="headerlink" title="mahotas"></a><a href="http://mahotas.readthedocs.io/en/latest/#" target="_blank" rel="noopener">mahotas</a></h3><p>&emsp;&emsp;<a href="http://mahotas.readthedocs.io/en/latest/#" target="_blank" rel="noopener">mahotas</a> 就像OpenCV一样依赖于NumPy数组。在Mahotas中实现的许多功能都可以在OpenCV中找到，但在某些情况下，Mahotas接口更容易使用。我们将使用Mahotas来补充OpenCV。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install mathotas <span class="comment">#安装mathotas</span></span><br></pre></td></tr></table></figure><div class="note danger"><p>安装失败提示需要  Microsoft Visual C++ 14.0 is required.<br>在<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/#mahotas下载对应版本" target="_blank" rel="noopener">https://www.lfd.uci.edu/~gohlke/pythonlibs/#mahotas下载对应版本</a>,<br>执行pip install mathotas-1.4.0.cp<strong><em>*</em></strong>.whl  安装</p></div><h3 id="scikit-learn"><a href="#scikit-learn" class="headerlink" title="scikit-learn"></a><a href="http://scikit-learn.org/" target="_blank" rel="noopener">scikit-learn</a></h3><p>&emsp;&emsp;<a href="http://scikit-learn.org/" target="_blank" rel="noopener">scikit-learn</a> 是机器学习的算法和工具的集合</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install scikit-learn</span><br></pre></td></tr></table></figure><h3 id="scikit-image"><a href="#scikit-image" class="headerlink" title="scikit-image"></a><a href="http://scikit-image.org/" target="_blank" rel="noopener">scikit-image</a></h3><p><a href="http://scikit-image.org/" target="_blank" rel="noopener">scikit-image</a>  是图像处理算法的集合<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install -U scikit-image</span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&emsp;&emsp;此书需要的包都安装完毕了，以上使用到的包在此<a href="https://www.scipy.org/about.html" target="_blank" rel="noopener">https://www.scipy.org/about.html</a>有罗列，有兴趣的朋友可以查看相关官网详细了解各包的具体使用方式和包含的方法.</p><div class="note warning"><p>如果有包安装失败建议在<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/" target="_blank" rel="noopener">python库</a>中找到对应的whl包，使用下载包在相关python 环境中执行 pip install …..whl</p></div><blockquote class="blockquote-center">凡事往简单处想，往认真处行</blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/images/practicalpythonopencv.png&quot; width=&quot;200&quot; height=&quot;300&quot;&gt;
&lt;p&gt;这是我在学习&lt;a href=&quot;https://jackmk.ctfile.com/fs/14155983-233384097&quot; ta
      
    
    </summary>
    
      <category term="opencv" scheme="https://harveyyeung.github.io/categories/opencv/"/>
    
    
      <category term="opencv" scheme="https://harveyyeung.github.io/tags/opencv/"/>
    
      <category term="python" scheme="https://harveyyeung.github.io/tags/python/"/>
    
  </entry>
  
</feed>
